 JAVA INTORDUCTION:-
=====================
Definition of Java:-
====================
-->java is a simple , High-level, secure, platform independent, Robust, Dynamic , Multi threading and Object oriented programming language used for developing Both Standalone and Web(internet) Applications.
-->java is case sensitive programming language.
Note: Not a pure object-oriented language because it supports primitive data types like int, char etc.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
WHY JAVA..?:-
============
-->Java Programming language is Invented for Developing Internet Applications by providing Platform independence(Write once run anywhere).
-->Java is one of the most popular programming language in the world.
-->Java is popular programming language for client-server web applications.
-->It has more demand in the current job market.
-->it is easy to learn and simple to use.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
HISTORY OF JAVA:-
=================
-->Java history was started with the Green Team.
-->The Green Team started a project to develop a language for digital devices such as Television.
-->It works on Internet Programming.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
CREATION OF JAVA:-
==================
-->Java was developed by James Gosling and his team (Mike shredding, park Naughton) at "Sun Microsystems INC" in the year 1991.
-->James Gosling is also known as Father of the java.
-->Initially, James Gosling call it as "Green Talk" with the file extension as ".gt"
-->Later on it is renamed as "OAK" and again it is renamed as "java" in the year 1995 , because "oak" is already a trademark by the "oak Technologies".
-->"java is a island in Indonesia where a first coffee was produced."
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Java Divided into Three Categories:-
-------------------------------------
J2SE(java 2 standard Edition): for creating desktop-based applications.(File/input, collections,etc...)
J2EE(java 2 Enterprise Edition) : for Developing enterprise web-based applications.(jsp,servlets,jpa,etc...)
J2ME(java 2 Micro Edition): for Developing mobile-based applications.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
JDK:- Java Development kit(JDK) is a software development kit required to develop applications in java. When you download JDK, JRE is also downloaded with it.
JRE:- Java Runtime Environment(JRE) is a software Package that provides java class libraries, JVM and other components that are needed to run java programs.
JVM:- Java Virtual Machine(JVM) is an interpreter that converts byte code into machine level language code .
=================================================================================================================================================================
JAVA PROGRAM STEP BY STEP EXECUTION PROCESS:-
===============================================
-->Step-1:  create a java source code file with .java extension
-->step-2:  compile the source code using the java compiler which will creates a bytecode file with .class extension.
-->Step-3:  class loader reads both user defined and library classes into memory for execution.
-->step-4:  bytecode verifier validates all the byte codes are valid.
-->step-5:  JVM(java virtual machine) reads bytecodes and translate into machine Level Language for execution. 
=================================================================================================================================================================
JVM ARCHITECTURE:-
===========================
Why do we need JVM:-
--------------------
-->Operating System is not provided environment to execute java Applications or programs.
-->To execute java programs or Applications we must need  to have JVM.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
what is JVM? -->JVM is a interpreter which is responsible for loading, verifying and executing byte code created in java.
-->".Class" file is the input to the JVM.
ARCHITECTURE:-
--------------
".class"--> 1)Class Loader Subsystem:
                 -->Loading(Classes will be loaded by this Component)
                      -->Bootstrap Class Loader -->Responsible for loading classes from BootStrap class path, Nothing but rt.jar(contins all of the compiled 
                         class files)
                      -->Extension Class Loader -->Responsible for loading Classes find in the ext.folder("/jre/lib").
                      -->Application Class Loader -->Responsible for loading Application-level class path, path mentioned in environment variable, etc..
                             |
                           CLASS NOT FOUND EXCEPTION
                 -->Linking
                      -->verify -->Bytecode verifier will verify whether the generated bytecode is proper or not.
                      -->Prepare -->For all static variables memory will be allocated and assigned with default values.
                      -->Resolve -->All symbolic memory references are replaced with original references from Method Area.
                -->Initialization -->we assign original values to the static variables and static blocks get executed.
             2)Memory management or Run time Data Area:
                  -->Method Area
                       -->The "Method Area" is Loading Class Level Data.
                       -->All the static Data will be stored in 'Method Area".
                  -->Heap Area
                       -->The "Heap Area" is Loading Object Level Data.
                       -->All the Instance data Will be Stored in "Heap Area".
                  -->Stack Area
                        -->Executing the method When we Called is happening inside the Stack Area, When Main  method and all other methods after completing 
                            execution will be removed from Stack Area.
                  -->PC Registers -->They will hold the address of the current executing instruction once execution is completed they will updated with next 
                                      instruction.
                  -->Native Method Stack -->native method stack holds the native method area information.
              3)Execution Engine
                   -->Interpreter 
                         -->Converts byte Code into machine level language to execute.
                   -->JIT(Just-In-Time) Compiler : suppose if we call a method for many times in main method then the JVM will go to the interpreter only once 
                     and remaining time the JIT Compiler  will take care of it , that is the use of JIT(i.e. used for better performance of Java Applications 
                     during runtime). 
                   -->Garbage Collection:
                        -->Garbage Collector Removes Unreferenced Objects.
                        -->This garbage Collection can be done in two ways:
                            -->By Making the reference variable as "Nullify(t=NULL)", and assigning one reference variable to other(t1=t).When we use any one of 
                               the above method we need to call garbage Collector(System.gc()) then the Garbage Collector will Call the Finalize() method and it 
                               will remove garbage value or nullify value from the memory.
              4)Native Method Libraries  -- This a Collection of Native Libraries which are required for the Execution engine.
                                            
              4)Java Native Interface(JNI) -- JNI will be interacted with the Native method libraries and provide the Native libraries required for the 
                                              Execution Engine.
=================================================================================================================================================================
APPLICATIONS OF JAVA:-
==========================
  -->java is used in "DESKTOP APPLICATIONS"
  -->"MOBILE APPLICATIONS"
  -->"ENTERPRISE APPLICATIONS"
  -->"WEB APPLICATIONS"
  -->"EMBEDDED SYSTEMS"
  -->"GAMING".
=================================================================================================================================================================
ADVANTAGES OF JAVA:-
==============================
-->java  is a popular and widely used programming language with many advantages.
     -->platform independent -->compiled code can run on any Platform(OS) where JVM is installed(WORA).
     -->object-oriented programming -->
     -->Simple
     -->Secure
     -->High-performance
     -->memory management
     -->multi-threading
     -->community support
     -->Dynamic
     -->Robust-->Garbage Collection and exception handling makes the java programming as Robust.
     -->Architecture Neutral -->it is not depend on the Architecture design.
=================================================================================================================================================================
-->What is meant by "public static void main(String[] arms)"?
     -->In public static void main(String arms[])
              -->public means direct access to the JVM(Java virtual machine).
              -->static means direct access to the JVM(Java virtual machine)  but without creating any object.
              -->void means where as main function does not return anything.
              -->main means, it is callable environment to the java programs  where we can call user defined and pre-defined functions.
              -->why "String arms[]"(String array arguments)? :- if you want to send arguments through command line then we need to go for "String[] arms".
-->We can give "synchronized, strictfp, final" keywords for main method other than static..
-->CLA(Command Line arguments)
-->varaible argument:-
       void m1(int ...a){
       }

-->sop(System. out. println):-
--------------------------------
-->"System" is a predefined class from Java. Lang Package.
-->"out" is a static variable in system class and referring print stream class.
-->"println" is a method from print Stream class.
-->We have total of 10 println methods with all primitive data types and object datatypes as arguments.
=================================================================================================================================================================
DIFFERENCE BETWEEN C++ AND JAVA:-
=======================================================
--> C++                                                                JAVA
   ======================                                       =====================================
    1.It is plat-form dependent                                    1.It is plat-from Independent
    2.It is mainly used for system programming                     2.It is mainly useful for application programming
    3.It supports go to statement                                   3.It doesn't supports go to statements
    4.It supports multiple inheritance                              4.It doesn't supports multiple inheritance through class. It is achieved through interfaces.
    5.It supports structures and unions                            5.java doesn't supports structures and unions.
    6.c++ supports pointers and we can write a pointer program     6.java does not supports pointers instead they developed references(address of the objects)
    7.c++ supports operator overloading                            7.java doesn't supports operator overloading.
=================================================================================================================================================================
WHAT A CLASS CAN CONTAIN:-
==========================
1) Data Members:
        -->Static Data members(variables + Methods)
        -->instance Data Members(Variables + Methods)
2)Blocks:
    -->Static Blocks
    -->Instance Blocks
3)Constructors:
      -->default
      -->Parametrized Constructor
4)Interfaces
5)Inner Classes
----------------------------------------------------------------------------------------------------------------------------------------------------------------
CLASS:-
=======
-->Class is a Blue Print of an object or it is a Template.
-->We can call class as a user defined data type.
-->By Default class extends from Object in java.
-->class is a static memory allocation.
OBJECT:-
=========
-->An Instance of a class is called an object.
-->Object is a Dynamic Memory Allocation.
-->Object is a real time entity.
-->Object consists of state , behavior and Identity.
Note: Where as Class is Dummy and Object is Real.
-->The Java Compiler will provide default constructor for your class to create an object.
creating object:-
-----------------
-->ClassName A = new ClassName();
          or
    new ClassName();
=================================================================================================================================================================
READING INPUT IN JAVA:-
========================
Scanner class:- Scanner Class is a predefined class in "java. util" package
  -->Scanner sc=new Scanner(System.in); 
     byte r   =sc.nextByte();
     short m  =sc.nextShort();
     int n    =sc.nextInt();
     long s   =sc.nextLong();
     double w =sc.nextDouble();
     float f  =sc.nextFloat();
     String q =sc.nextLine(); or sc.next();
     Char ch  =sc.next().charAt(0 or i);
BufferedReader class:-
    -->InputStreamReader s=new InputStreamReader(System.in);
    -->BufferedReader br=new BufferedReader(s);
       ---->int n = Integer.parseInt(br.readLine());
       --->float f= Float.parseFloat(br.redLine());
=================================================================================================================================================================
-->To find Number of digits in the given number use this logic: (int)Math.log10(num)+1;
-->TO separate the digits from first then use the below logic:
        while(num>0)
        {
           int r= num/(int)Math. Pow(10,d) ;
           num=num%(int)Math. Pow(10,d);
        }
=================================================================================================================================================================
PRINTING OUTPUT:-
==============================
-->there are 3 ways of printing output.
-->1.System.out.println("HELLO WORLD");
-->2.System.out.print(x);
-->3.System.out.printf("THE VALUE OF x IS :"+x);
-->while printing the floating point numbers after decimal point print only 2 digits.
float pi=3.142345f;
System.out.println(pi);
-->Formatting the output:-
System.out.format("%.2f",pi);
System.out.printf("%.2f",pi);
=================================================================================================================================================================
"JAVA LANGUAGE FUNDAMENTALS":-
============================================================
JAVA IDENTIFIERS:-
============================
-->java identifiers are used for identification purpose (or) Any name of the Project, package, class, interface, Method, variable is called as Identifier.
-->valid identifiers:-->($,_,[A-Z],[a-z],[0-9])-->but should not start with numbers.
-->Invalid identifiers:-->(@,#,%,-,...)
  RULES FOR IDENTIFIERS:-
 =====================================================================
   1)Java Identifiers can use (a-z) or (A-Z) or (0 - 9).
   2)Java Identifiers should not start with numeric values(0 -9)(Syntax error at token 1).
   3)Java Identifiers should not contain any Special Characters except "_" and  "$" , we can start identifiers with "_" or "$".
   4)Java Identifiers should not be a Java Keywords.
=================================================================================================================================================================
JAVA KEYWORDS:-
==================
"Primitive Datatypes(8), Application level or oops(14), Access Modifiers(12), Exception handling(5), Logical Statement(11)"
PRIMITIVE DATATYPES KEYWORDS:-
-------------------------------
For Representing The Numbers:
  -->byte
  -->short
  -->int
  -->long
------------------------------------------
For Representing floating Decimals:
  ->float
  ->double
----------------------------------------------------------
For Representing characters and true or false conditions:
  ->char
  ->Boolean
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
APPLICATION LEVEL (OR) OOPS KEYWORDS:-
---------------------------------------
 -->"package" :- package is a keyword to create package for collection of classes and interfaces.
 -->"import"  :- To import classes or interfaces or Enums  from one package to another package.
---------------------------------------------------------------------------------------------------
 -->"class"    :- Class is a blue print of an object or template or user defined datatype.
 -->"interface":- interface is Blueprint of a class. 
 -->"Enum"     :- To represent constant values we use Enum like a class.
 -->"new"      :- new keyword is used to create object for a class.
 -->"instance of" --> to check status of the object from another object.
---------------------------------------------------------------------------------------------------
-->"void" -->return nothing
-->"return"  -->return something in a method based on the return type.
--------------------------------------------------------------------------------------------------
-->"this" :-> this Keyword is used "To invoke current object data members".
-->"super" :-> super keyword is used "To invoke super object data members".
-->"implements" 
-->"extends"
-->"assert"
----------------------------------------------------------------------------------------------------------------------------------------------------------------
ACCESS MODIFIERS KEYWORDS(12):-
--------------------------------
-->"private" :-  private is a keyword, we cannot  use for a class but we can use inside the class.(The Scope of private is within  the class).
-->"<default>" :- The Scope of default is within the package.
-->"protected" :- protected is a keyword , we cannot use for a class but we can use inside the class.(The Scope of Protected is "within the package + outside of the packages of subclasses:).
-->"public" :- public is a keyword we can user for a class and also we can use inside the class. (The Scope of public is within the project Anywhere).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-->"abstract" :- abstract is a keyword 
                      --> we can use for methods for declaration but not for implementation
                      --> we can use for classes for not creating an object to our class.
-->"static"   :-  static is a keyword we can use for data members and blocks. 
                  if we use static for a variable or data then it is constant for all objects.
                  if we use static for a method or blocks then it will loading to  the memory without creating object.
-->"strictfp" :-  strictly follows floating point data in all the systems.
-->"synchronized" :-synchronized is a keyword , we can go and use in multithreading to acheive synchronization.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-->"final" :-  final is for class then we cannot extends that class.
               final is for method then we cannot override that method in child class.
               final is for variable then we cannot change the value.
-->"transient":- transient is a keyword we can use it in serialization concept.
-->"Volatile" :- volatile means keep on changing , we can use it in multithreading when the threads are sleeping still you want to make your variables to change  the values.
-->"native"
----------------------------------------------------------------------------------------------------------------------------------------------------------------
EXCEPTION HANDLING(5):-
------------------------
-->try
-->catch
-->finally
-->throw , throws
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
LOGICAL STATEMENT:-
--------------------
-->if
-->else
-->for
-->while
-->do while
-->switch 
-->case
-->continue
-->go to
-->const
=================================================================================================================================================================
JAVA  DATATYPES:-
=======================================
-->There are Two types of Data types in java : they are "Primitive Data types " and "Non-primitive datatypes"
-->Primitive datatype's in java are pre-defined by a java language and named as the reserved keywords. As primitive datatypes does not share a state with other primitive values. The Data in data types is stored in a 2's complement way. ( -2^n to 2^n-1)
-->byte (Byte)        ->size->1byte(8 bits)-->max value we can store in byte is 127 and min value is -128 -->byte bytevar;
                                                                                                (Byte.SIZE,Byte.MAX_VALUE,Byte.MIN_VALUE);
-->short(Short)       ->size->2bytes(16 bits)-->max value we can store in short is 32767 and min value is -32768 -->short shortvar; 
                                                                                                (Short.SIZE,Short.MAX_VALUE,Short.MIN_VALUE)
-->int(Integer)      ->size->4bytes(32 bits) -->max value we can store in int is 214748 and min value is -2147483647 -->int intvar; 
                                                                                                (Integer.SIZE,Integer.MAX_VALUE,Integer.MIN_VALUE)
-->long(Long)        ->size->8bytes(64-bits)-->long longvar;          
                                                                                                (Long.SIZE, Long.MAX_VALUE,LONG.MIN_VALUE)                                       
-->float(Float)      ->size->4bytes(32 bits)-->float floatvar;
                                                                                                (Float.size(), Float.MAX_VALUE,Float.MIN_VALUE)
-->double(Double)    ->size->8bytes(64 bits)-->double doublevar;
                                                                                                (Double.size(), Double.MAX_VALUE,Double.MIN_VALUE)
-->boolean           ->size->1bit  -->boolean boolvar;
-->char              ->size->16-bits-->char charvar; ( 0 to 65535) -->char data types is a single 16-bit Unicode characters.
-->All integers can be characters(by the concept of ASCII Values) and all Characters can be a integers.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Non-Primitive Data types(Wrapped object data types, pre-defined object data types, user-defined object data types):-
====================================================================================================================
-->String        
-->StringBuffer   
-->Math
-->BigInteger 
      -->It is a predefined class and predefined object datatype , it can store value larger than "int" and "long".
      -->synatx:-  BigInteger b= new BigInteger("232097329209027598383833793830383");
                   BigInteger b1= new BigInteger("2320973292090275983834865484646438463830383");
      -->Following are some the methods that BigInteger have:
              -->b. add(b1);
              -->b. multiply(b1);
-->BigDecimal
       -->BigDecimal b2=new BigDecimal("467686969670707.6868686868");
-->Student, Employee, Address,....(user-defined object datatypes)
-->"NULL" is the Default value of any object data type.
=================================================================================================================================================================
JAVA TYPECASTING:-
====================
-->Type casting is nothing but when we assign a value of one primitive datatype to another datatype.
-->there are two types of type casting they are:
      1.Widening type casting(Automatic) :-  converts smaller datatype to larger datatype size. 
         byte -> short -> char -> int -> long -> float -> double.
      2.Narrowing type casting(Manual) :- converts  larger datatype to smaller datatype size
         double -> float -> long -> int -> char -> short -> byte.
-->Example for automatic or widening :-
          int a = 9;
          double b = a; -->this is nothing but implicit casting.
-->Example for manual or narrowing:-
          double c = 9.0;
          int d = (int)c; -->this is nothing but explicit casting.

-->Primitive data types can be converted to Wrapper class objects that conversion is called as Auto Boxing
  eg:- int i= 10;
       Integer i1=i;
-->Wrapper class objects can be converted to primitve data types that conversion is called as Auto unBoxing.
   eg:- Integer i2=100;
        int i3=i2;
-->All Strings can be converted to Wrapper class objects.
  eg:- String s="123";
       int res=Integer.parseInt(s);
================================================================================================================================================================
JAVA WRAPPER CLASSES:-
=======================
-->Java Wrapper classes provides a way to use primitive datatype's as objects.
--->  Primitive datatypes                Wrapper Object Data Types
     ========================          ==============================
       byte(8bits)              -->      Byte
       short(16 bits)           -->      Short
       int(32 bits)             -->      Integer
       long(64 bits)            -->      Long
       float(16 bits)           -->      Float
       double(32 bits)          -->      Double
       char                     -->      Character
       boolean(1 bit)           -->      Boolean

-->For converting one primitive datatype to another datatype we have type casting but to one type to another type by using wrapper class objects we have folowing methods.
     -->byteValue();
     -->shortValue();
     -->intValue();
     -->longValue();
     -->floatValue();
     -->doubleValue();
     -->charValue();
     -->toString();
-->example:-
  ==========
  import java. util.*;
    public class M{
        public static void main(String args[]){
                Integer a = 5;
                Float f = 5.66;
                Character c = 'A';
           System.out.println(a);
           System.out.println(f);
           System.out.println(c);
           System.out.println(f.intValue());
           System.out.println(a.doubleValue());
          System.out.println(c.toString());
       }
   }
================================================================================================================================================================
JAVA LITERALS:-
=================
-->Literal is a Constant value which we are storing it into a variables.
-->Java Language Specifies Five Major types of literals, they are:
       --Integral Literals
             --Decimal Literals (Decimal Numbers starts  as a normal number and its range is 0 to 9)
             --octa Decimal Literals(Octa Decimal Numbers prefixed with "0")(range 0 to 8)
             --Hexa Decimal Literals(Hexa Decimal Numbers prefixed with "0X" or "0x") (range 0 to 9, a to f)
       --Floating Literals -->octa and hex decimal literals are not possible for double datatype.
       --char Literals -->char data types is a single 16-bit Unicode characters.
       --Boolean Literals -->(true or false)
       --null literals -->most of the object reference variables are assigned with null value.
       --String Literals
-->Literals can be any Number  or text or other information that represents a value.
-->We will use Literals in addition to variables in java  statements.
=================================================================================================================================================================
TYPES OF VARIABLES:-
=====================
-->DIVISION 1:-
--------------
   -->Based on type of value represented by a variable all variables are divide into two types:
          "Primitive variables" : can be used to represent primitive values.
          "object variables"    : can be used to refer to objects.
---------------------------------------------------------------------------------------------------
-->DIVISION 2:-
---------------
   -->Based on behavior and position of declaration all variable are divided into three types :
        1) "Instance variables" :
             -->The value of Instance variables varies from object to object.
             -->For every object a separate copy of Instance variable will be created.
             -->Instance variable will be created at the time of object creation and destroyed at the time of object destruction.
             -->Instance variables will be loaded in to the Heap Area when object is created.
        2) "Static Variables" :
              -->The Value of Static variables will be remain constant for all objects.
              -->For Any object , only one copy of static variable will be created.
              -->Static variables will be created at class level and loaded in to the method Area.
        3) "Local Variables" :
              -->The Local variables will be created inside the main method.
              -->Duplicates can be allowed to this variables.
              -->JVM is Not responsible for loading these local variables.
-->Compared to static , instance and local , the highest priority will be given to local variables.
=================================================================================================================================================================
TYPES OF METHODS:-
====================
-->Method means it's a behavior of a class.
                or
-->Method means Collection of logics and collection of statements.
                or
-->Method is a block of code which execute when we called.
-->We cannot write one method inside another method.
-->we can write a block inside of the Any Method.
-->we can call one method in another different method.
-->we can call the method in same method but we will get stackoverflow error.
-->The main aim of creating methods is to reuse the code any number of times.
-->There are 4 types of methods they are:
    -->Method with no "return type" and with "no arguments".
    -->method with "return type" and with "no arguments".
    -->method with "no return type" and with "arguments".
    -->method with "return type" and with "arguments".
Example Program:-
====================
package com. sample;
import java. util. Scanner;
public class TypesofMethods4 {
     static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		TypesofMethods4 t = new TypesofMethods4();
		t.m();
		t.m1(10,20);
		int age = t.m2();
		int sum= t.m3(2333, 333);
       //t.m3(int x=2, int y=3) --->We cannot pass arguments in this way -->it will give token error.
		System.out.println("my Age is:"+age);
		System.out.println("my sum is:"+age);
        
	}
	
	void m()   //With "No return Type" and with "No arguments"
	{
		System.out.println("Hai Ajay");
	}
	 
	void m1(int x , float y) {    //method with "no return type" and "with arguments"
		System.out.println("Sum of two Numbers is:"+(x+y));
		
	}
	
	int m2() //method "with return type" and "with no arguments"
	{
		System.out.println("enter your age:");
	  int age = sc.nextInt();
	  return age;
	}
	
	int m3(int x, int y) //method "with return type" and "with arguments"
	{
		return (x+y);
	}

}
=================================================================================================================================================================
JAVA CONSTRUCTORS:-
=====================
Why We need Constructors..?
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
     -->To Initializing an object and initializing instance data but not static data  we need Constructor.
     -->Without Constructor there is no chance to create the object.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Constructor..?
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-->Constructor is a special member function which is used to initialize objects. When Object is created constructor get invoked Automatically.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
What are the types of Constructor types:
-----------------------------------------
-->Default Constructor:-
      -->why?--> If in our class we don't have any constructor(no-args, parameterized) then "java compiler" will create a Constructor that is called as "default 
           Constructor".
-->No-arg Constructor:-
      -->why?--> If in a class we are having a parametrized constructor then the java compiler will not create or call any default constructor so that to create 
         an object with no args we will go for the No-args Constructor. 
-->Parameterized Constructor:-
      -->why?-->While Creating an object, if we want to  send any  values to that object then we can go for the parameterized constructor.
-->"this" keyword is used to invoke current class object data members and to maintain the "code readability".
-->"this()" method is used to call current class Constructor. It cannot be used in a method, and this should be used only inside the constructor and written at 
    first line.
-->"super" keyword is used to invoke super class  object data members.
-->"super()" method is used to call super class constructor.
-->constructor Chaining
       -->If we are calling  one constructor into another constructor by using "this()"(incase of single class) and "super()"(incase of multiple classes) 
         methods is known as constructor chaining. 
-->Copy Constructor
       -->if we are copying one constructor into another constructor by using object reference variable.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
RULES FOR CONSTRUCTORS:-
----------------------------
1)Class name and Constructor name must be same.
2)Constructors should not return anything not even void.
3)Applicable modifiers for constructors as below: 
    -->private
    --><default>
    -->protected, public 
  Note: other than the above modifiers if we give any other modifiers then we will get the compile time error.
4)"this()" and "super()" must be in the first line of any constructor.
5)"this()" and "super()" must need to be call in constructor only but not in methods.
6)If we didn't create any constructor for a class , java compiler will create a default constructor.
7)If we have any constructor in our class then java compiler does not create any default constructor.
8)If we have parameterized constructor and we need to create an object with no values then we need to go for the no args constructor.
9)"this" and "super" keywords can used in both methods and constructors but not used in static methods.
10)In java ,constructor overloading is possible.
11)In one Constructor, we cannot call both this() and super().
12)The scope of "default constructor" is the "scope of class".
================================================================================================================================================================
ESCAPE SEQUENCES:-
==================
single quote ---> ' '
double quote ---> " "
new line     ---> \n
tab space    ---> \t
carriage return --> \r
Form Feed    ---> \f
backspace    ---> \b
backslash    ---> \\
-->While loop is called entry Controlled Loop or sentinel Loop and Do while loop is called exit controlled loop.
=================================================================================================================================================================
JAVA ARRAYS:-
=================
Why wee need Arrays?
----------------------
       -->structuring the data in a proper way from unstructured data.
       -->It is More Readable to maintain the code.
       -->To maintain continuous memory allocation.
----------------------------------------------------------------------------------------
What is Array?
--------------
 -->Array is an object.
 -->Array is a index based, collection of homogeneous data elements into a single unit with fixed size.
 -->Array is a fixed and mutable(i.e. we can replace the value of a array element)
Array Creation:-(For Creating an array we need to follow four steps they are: Declaration, Creation, Intialization, Representation)
=================
1) Declaration
    --> int[] ages;
2)Creation
    ages = new int[n]; //n is the size and index is "0 to n-1"
   Note: while creating an array, we must specify the size.
3)Initialization
    ages[0] = 22;
    ages[1] = 23;
    ages[2] = 24;
    ages[3] = 25;
4)Representation.
    //for(Initialization; condition; increment/decrement){}
    //Initialization : where you want to starts from : int i= 0
    //condition     : up to where u want to go ?: i<100
    //Increment     :  Initial values incremented by +1: i++
   for(int i=0;i<n; i++){
     System.out.println(ages[i]);
   }
-->The Maximum Range of Array is : Integer maximum value(2147483647).
-->We can create and initialize an array in a single line by using "{}".
//Reading the elements from console using scanner class..
---> for(int i=0;i<size; i++){
       A[i] = sc.nextInt();
   }
//for-each loop or enhanced for loop
-->for(int i : A){
    System.out.println(i);
   }

2D Arrays:-
==============
Whenever you want to represent rows and columns we need to go for 2Dimensional arrays.
syntax:-
-->int[][] A = new int[3][3];
          (or)
-->int[] A[] = new int[3][3];
for(int i=0;i<A. length; i++){
  for(int j=0;j<A[i].length; j++){
     System.out.println(A[i][j]);
  }
}
-->for(int[] n1 : A){ //for -each loop for 2D array.-->first convert 2D to 1D array and then 1D to normal Number.
      for(int n : n1){
         System.out.print(n+" ");
      }
  }


JAGGED ARRAY:-
===============
-->Array of Arrays is called as jagged array.
 syntax:-
  int[][] A = new int[2][];
   A[0] = new int[4];
   A[1] = new int[3];

Example program for prime Number:-
======================================
import java.util.Scanner;
public class M{
   public static void main(String args[]){
       scanner sc =new  Scanner(System.in);
       System.out.println("Enter the size:");
       int s = sc.nextInt();
       int[] A = new int[s];
       System.out.println("Plz enter the array elements:");
       for(int i=0;i<s;i++)
       {
             A[i]=sc.nextInt();
        }
        System.out.println("Prime Numbers for the Array are:");
        for(int i=0;i<s;i++){
          boolean flag = true;
          for(int j=2;j<A[i];j++){
                if(A[i]%j==0){
                    flag = false;
                    break;
                }
           }
           if(flag){
              System.out.println(A[i]);
           }
         }
   }
}

Bubble Sort Algorithm:-
=========================
Bubble Sort Algorithm is the Simplest Sorting Algorithm that  works by repeatedly Swapping the adjacent elements if they they are in wrong order.
Time Complexity: o(n^2) -->Worst time complexity
Space complexity : o(1)

Example program:-
======================
class Main{
  public static void main(String args[]){
       int[] A = {39,19,15,12,5,6};
       int tmp=0;
       for(int i=0;i<A.length;i++){
        int flag =0;
         for(int j=0;j<A.length-1-i;j++){
             if(A[j] > A[j+1]){
                tmp=A[j];
                A[j]=A[j+1];
                A[j+1]=tmp;
                flag = 1;
         }
       if(flag==0){
          break;
        }
      }
     for(int c :A){
          System.out.println(c);
     }

Selection Sort Algorithm:-
===========================
Selection sort is a Straightforward sorting Algorithm that operates by repeatedly finding the minimum element from an unsorted section of array and moving it to the beginning. This process continues until the entire array is sorted.
Time Complexity : o(n^2)
Space Complexity: o(1)

Example Program:-
==================
public class Array{
    public static void main(String args[]){
       int[] A = {39,19,29,12,15,5};
       for(int i=0;i<A.length;i++){
           int tmp=0;
           int min=i;
           for(int j=i+1;j<A.length;j++){
                 if(A[j] < A[min]){
                       min = j;
                 }
           }
           tmp=A[i];
           A[i]=A[min];
           A[min] = tmp;
       }
       for(int c : A){
         System.out.print(c+ " " );
      }  

3Dimensional Array:-
====================
Declaration and creation:-
---------------------------
int[][][] A = new int[3][3][3];
       	 (or)
int[] A[][] = new int[3][3][3];
         (or)
int[][] A[] = new int[2][2][2];

initialization:-
----------------
A[0][0][0] = 111;
A[0][0][1]=  222;
A[0][0][2]=  333;

A[0][1][0] =444;
A[0][1][1] =555;
A[0][1][2] =666;

A[0][2][0]=777;
A[0][2][1]=888;
A[0][2][2]=999;

  (or)
int[][][] A = { { { 111, 0, 0 } }, { { 0, 222, 0 } }, { { 0, 0, 333 } }, { { 444, 0, 0 } }, { { 0, 555, 0 } },
				{ { 0, 0, 666 } }, { { 777, 0, 0 } }, { { 0, 888, 0 } }, { { 0, 0, 999 } } };

Representation:-
---------------
for(int i=0;i<A.length;i++){
   for(int j=0;j<A[i].length;j++){
     for(int k=0;k<A[i][j].length;k++){
        System.out.print(A[i][j][k] + " ");
     }
     System.out.println();
  }
  System.out.println();
}

//using for each loop:-
------------------------
for(int[][] n2:A){
  for(int[] n1:n2){
      for(int n : n1){
          System.out.print(n+" ");
      }
     System.out.println();
   }
System.out.println();
}
=================================================================================================================================================================
ARRAYS CLASS:-
==================
  -->Arrays class is a built-in class in java that provides variuos utility methods for working with Arrays.
   Methods:-
        import java.uitl.Arrays;
        int[] Array={1,4,2,5,3,6,9};
       1) Arrays.sort(Array_name);   //sort the elements of the array in ascending order.
       2)int[] index=Arrays.binarySearch(Array_name,value); //search for specific element inthe array using binary search algorithm.
       3)boolean[] equal = Arrays.equals(Array1,Array2); //compares to Arrays for eqaulity.
       4)var list=Arrays.asList(Array_name);  //converts given array into the list.
       5)int[] copy=Arrays.copyOfRange(Array_name,value1,value2); //copies the specified range of Array elements to another Array.
       6)Arrays.fill(Array_name,value); //Fills specific value in to the array.
       7)Arrays.toString(Array_name)
=================================================================================================================================================================
JAVA LOGICAL STATEMENTS AND OPERATORS:-
=========================================
1)simple "if" and "else":-(Decision Making)
---------------------------------------------
syntax:-
  if(condition){//true
       //block of statements
  }//if we are not taking curly braces to the if block then it is going to take only one statement.
 else{//false
    //block of statements
 }

2)"Nested if":-(Decision Making)
-------------------------------
syntax:-
 if(condition1){
     //block of statements
     if(condition2){
        //block of statements
        if(condition3){
           //block of statements
        }
     }
}

3)"Nested if-else":-(Decision making)
-------------------------------------
if(condition1){
   //block of statements
   if(condition2){
      //block of statements
  }
  else{
     //block of statements
 }
}
else{
   if(condition 3){
        //block of statements
  }
  else{
   //block of statements
  }
}

4)"if-else-if":-(Decision making)
--------------------------------
syntax:-
if(condition1){
    //block of statements
}
else if(condition2){
   //block of statements
}
else if(condition3){
  //block of statements
}

5) "switch statement":-(Decision making)
----------------------------------------
A switch statement in java is used to execute a single statement when there are multiple conditions.
syntax:-
char Ch;
switch(expression or Ch){
     case 1 : //block of code
              break;
     case 2: { //we can give curly braces
             //block of code
             break;
             }
       |   
       |
     case n: //block of code
             break;
     default: //block of code
             break;
} 
     (OR)
switch(expression){
 case 1 --> //block of statements;
 case 2 --> //block of statements;
   |
   |
   |
 case n --> //block of statements;
 default --> //block of code;

6) "WHILE LOOP":-(looping Statements)
  ------------------------------------
  -->It is also called as entry controlled loop.
 syntax:-
  initialization;
  while(condition-->Boolean){
      //block of code;
     increment/decrement; //breaking value
  }
 
7)"DO WHILE LOOP":-(looping statements)
---------------------------------------
-->It is also called as exit controlled loop.
syntax:-
initialization;
do{
  //block of code;
}while(condition);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
OPERATORS:-
===========================================================
-->unary  operators:-(++(pre, post),--(pre, post))
   Post Increment: value will print first and then increment next.
   post Decrement: value will print first and then decrement next.
   pre  Increment: value will increment first and then print next.
   pre Decrement : value will decrement first and then print next.
-->Arithmetic Operators && shift operators:- (+,-,*,%,/, >>(right shift) or >>>,<<(left shift))
     -->Right shifting(>>) is nothing but division by 2 and Left shift(<<) is nothing but multiplication by2.
-->Relational operators:- (>,<,>=,<=,==,!=)
-->Logical operators:- (&&,||,!)
-->Assignment operators:- (variable=value, = ,+=,-=,/=,*=,%=,&=,|=,^=,<<=,>>=)
-->Ternary operator:- ((condition)?  true: false)
-->Bitwise operators:- (&,|,^)
-->instance of

Operators Precedence and Associativity(BODMAS):-
 ================================================
 1. unary operators have high precedence(+,-,++,--)
 2. ( ) -->parenthesis are having Second highest priority.(BO)
 3. *,/,% -->are having third highest priority.(DM)
 4. +(Addition) , -(Subtraction) -->are having fourth highest priority.(AS)
If we have same precedence operators in the equation:
  then for(*,/, %) the Associativity will be Left to Right.
  then for(+,-) the Associativity will be from Right to Left.
=================================================================================================================================================================
JAVA ACCESS MODIFIERS/SPECIFIERS:-
====================================
-->"private"   :- private is a keyword, we cannot  use for a class but we can use inside the class.(The Scope of private is within  the class).
                 USED FOR--> (inner class, variables, methods, constructors)
-->"<default>" or undefined :- The Scope of default is within the package.
                 USED FOR--> (class, inner classes, variables, methods, constructors, interfaces)
-->"protected" :- protected is a keyword , we cannot use for a class but we can use inside the class.(The Scope of Protected is "within the package + outside of 
                  the packages of subclasses by using sub class object reference variables).
                  USED FOR -->(inner classes, variables, methods, constructors)
-->"public"    :- public is a keyword we can user for a class and also we can use inside the class. (The Scope of public is anywhere in the project).
                  USED FOR -->(class, inner classes, variables, methods, constructors, interfaces)
-->"final"     :- final is for class then we cannot extend that class.(inheritance is not possible)
                  final is for method then we cannot override that method in child class.
                  final is for variable then we cannot change the value of that variable.
                  USED FOR -->(class, inner classes, variables, methods)
-->"static"    :- static is a keyword we can use for data members and blocks. 
                  if we use static for a variable or data then it is constant for all objects.
                  if we use static for a method or block then it be will loading in to the Method Area without creating object.
                  static data remains constant for every object but instance data varies for object to object.
                  USED FOR -->(variables, methods, blocks)
-->"abstract"  :- abstract is a keyword 
                      --> we can use for methods for declaration but not for implementation
                      --> we can use for classes for not creating an object to our class.
                  USED FOR -->(class, methods)
-->"strictfp"  :-  strictfp is a keyword , which strictly follows floating point data in all the systems.
                  USED FOR --> (Class, methods)
-->"synchronized" :- synchronized is a keyword , we can go and use in multithreading to achieve synchronization.
                  USED FOR--> (Blocks, methods)
-->"transient"  :- transient is a keyword we can use it in serialization concept.(used for variables)
-->"volatile"(used for variables)
-->"native"(used for methods)
================================================================================================================================================================
JAVA STRING HANDLING:-
======================
-->String is a Non-primitive datatype or object datatype.
-->String is a class from java.lang package.
-->String is Immuatable(we cannot change the value of these  objects) object where as String Buffer and String Builder are Mutable(we can change the value of 
   these object) objects.
-->A Collection of characters which are represented into a single variable using "Double Quotes" is called a String.
-->String is a thread Safe.

--> There are 4 ways to create String:-
    1) String Literal:-
    --------------------
       String s = "Ajay"  -->Loaded into String Constant pool(SCP) --> Special memory from Heap area.

    2) String Object:-
    ----------------------
       String s1 = new String("Ajay1") -->Loaded into Heap Area.

    3) StringBuffer:-
    -----------------------
      StringBuffer sb = new StringBuffer("ajay");

    4) StringBuilder:-
   --------------------------
     StringBuilder SB = new StringBuilder("ajay");


JAVA STRING METHODS:-
======================
1) "charAt(int index)" :- Returns the character at the specified index.(o/p:- character)
   eg:- char c = s.charAt(i);

2) "length()" :- Returns the Length of the String.(o/p:- integer)
    eg:- s.length();

3) "codePointAt(int index)":- Returns the unioce character at the specified index.(o/p:- return ASCII Value -->integer)
    eg:- int res = s.codePointAt(index);

4) "codePointBefore(int index)" :- Returns the unicode character before the specified index.(o/p:- integer)
    eg:- int res1= s.codePointBefore(index);

5) "equals(String s1)" :- Compare  String "s" with another String "s1".(o/p :- returns true or false)
    eg:- boolean  res= s.equals(s1);

6) "equalsIgnoreCase(String s1)" :- Compare String "s' with another String "s1" ignoring case considerations.(o/p:- return true or false)
    eg:- boolean res1= s.equalsIgnoreCase(s1);

7) "compareTo(String s1)" :- Compare two Strings lexicographically(based on ascii values).(o/p:- integer)
    eg:- int res= s.compareTo(s1);

8) "compareToIgnoreCase(String s1)" :- Compare two Strings lexicographically, ignoring case differences.(o/p:- integer)
    eg:- int res1=s.compareToIgnoreCase(s1);

9) "concat(String s1)" :- concatenate String "s1" to the end of String "s".(o/p:- String)
   eg:- s=s.concat(s1);

10) "contains(character sequence c)" :- Returns true if and only if the character 'c'  present in the character sequence of a String "s".(o/p:- boolean)
    eg:- boolean res = s.contains("a");

11) "toUpperCase()" :- Converts all the characters of a String "s" in to Upper case.(o/p:- String)
   eg:- s.toUpperCase();

12) "toLowerCase()" :- Converts all the characters of a String "s" in to Lower Case.(o/p:- String)
    eg:- s.toLowerCase();

13) "trim()" :-  To remove leading and trailing spaces in a String "s" we need to go for "trim()" method.(o/p:- String)
    eg:- s.trim(); -->System.out.println(s.trim());

14) "replace(charSequence target or delimter , charSequnce replacement)" :- To remove spaces in between a String based on Strings.(o/p:- String)
     eg:- s.replace(" ", "");

15) "replaceAll(String regexp, String replacement)" :- To Remove spaces in between a String based on regular expressions.(o/p:- String)
    eg:- s.replaceAll(" ", "@");

16) "replaceFirst(String regexp, String replacement)" :- To Remove First space in between a String based on regular expressions.(o/p:- String)
    eg:- s.replaceFirst(" ", "@");

17) "split(String regexp)" :- Splits this string around matches of the given regular expression.(o/p:- array of String)
    eg:- String[] S2 = s.split(","); or String[] s2= s.split("//s");

18) "split(String regexp, int limit)" :- Splits this string around matches of the given regular expression.(o/p:- array of Strings)
     eg:- String[] s2= s.split("," , 3);

19) "indexOf(int ch)" :- Returns the index of first occurence of a given subString within this String "s".(op:- integer)
    "indexOf(int ch, int fromIndex);
     eg:- s.indexOf('a');

20) "lastIndexOf(int ch)" :- Returns the last index of a given subString within this String "s".(o/p:- integer)
     eg:- s.lastIndexOf('a'); 

21) "isEmpty()" :- Returns true if and only if the length() is "0".(o/p:- boolean)
     eg:- boolean res= s.isEmpty();

22) "toCharArray()" :- converts the given String into Array of Characters.(o/p:- char Array)
     eg:- char[] ch = s.toCharArray();

23) "substring(int beginindex)" :- Returns the String that is a subString of this String.(o/p:- String)
      eg:- s.substring(5); 

24) "substring(int beginIndex, int lastIndex)" :- Returns the String that is a subString of this String.(o/p:- String)
     eg:- s.substring(3,7);

25) "valueOf(int , byte,short, long,float,..)" :- Returns the String representation of  all the  primitive arguments.
     eg:- int a1=100;
          String a2=String.valueOf(a1);
26) "toString()" 

27) "Character.isDigit(ch);" :- It will return true or false based on it is digit or not.
  
28) "Character.getNumericValue(ch);" 
     
29) "Character.isUpperCase();"
     
30) "Character.isLowerCase();"
     
31) "Character.toUpperCase(ch);"
    
32) "Character.toLowerCase(ch);"

33) "intern()" :- Returns the canonical representation of a given String.(strng)
     eg:- s.intern();  s1.intern();
================================================================================================================================================================
STRING BUFFER && STRING BUILDER IN JAVA:-
============================================
StringBuffer:-
-------------
-->StringBuffer is a mutable Object(we can chage the value of these objects).
-->StringBuufer is a thread safe.
-->StingBuffer is a synchronized because its methods are thread safe and can be used in multithreading environment.
-->The Default Capacity of StringBuffer is 16.

StringBuilder:-
----------------
-->StringBuilder is also a mutable Object(We can the value of these objects).
-->StringBuilder is not a thread Safe.
-->StringBuilder is not synchronized, because its methods are not thread safe and cannot be used in multithreading environment.
-->The Default capacity of StringBuilder is also 16.

                        String                        StringBuilder                       StringBuffer
                      ------------                  -------------------                 ----------------------
Mutability->           Immutable                        Mutable                              Mutable

Thread Safety->        Thread Safe                    Not thread safe                       Thread Safe

Memory Efficiency->    High (SCP)                    Efficient(heap area)                   Less Efficient(heap Area)

Performance->          High(No-synchornization)       High(No-synchornization)              Low(due to synchornization)

usage->               This is used when we            This is used when thread              This is Used when thread safety 
                      Want immutability                Safety is not required.              is required.


syntax:-
--------
 StringBuffer sb = new StringBuffer();

StringBuilder:-
--------------
-->StringBuilder is a mutable object.
=================================================================================================================================================================
JAVA MATH:-
=====================
import java.io.*;
-->Math.max(x,y); //returns the maximum value.
-->Math.min(x,y); //returns the minimum value.
-->Math.abs(x); //returns the absolute value.
-->(int)Math.random()*10; //return the random values.
===============================================================================================================================================================
JAVA RECURSION:-
====================
-->Recursion is the technique of making a function call itself. This Technique provides a way to break down complicated problems into simple problems which are easier to solve.
Example:-
  public class Main{
      public static void main(String args[]){
           Scanner s = new Scanner(System.in);
           int num=s.nextInt();
           int res= sum(num); 
          System.out.println(res);
     }
     public static int sum(int n){ 
          if(n>0){
               return n+sum(n-1);
          }
           else
            {
              return 0;
            }
     }
  }
================================================================================================================================================================
JAVA OOPS:-
============
-->OOPS stands for object oriented programming structure or system.

WHY...?
-----------
--> To write a Program in a structured or organised or proper way, we must need to  go for oops.

WHAT... is OOPS?
----------------
--> If any program consists of below principles then we can call it  as object oriented programming.
      1)Encapsulation -- Security or Modularity (use)
      2)Abstraction   -- Security or flexibility (use)
      3)Inheritance   -- Reusability(use)
      4)polymorphism  -- Flexibility(use)

where... we use?
-----------------
--> Without OOPS , we cannot even write any simple java program, even it is very simple java program we are using oops.    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

ENCAPSULATION:-
=======================
-->It is a Combination of :
        - Data Hiding --> Hiding the data
             +
        - Abstraction --> Hiding the implementation.

-->Encapsulation means, Binding the data or Wrapping the data or bundling the data with "related functionalities" in to a single unit.
-->JAVA API is the best example of Encapsulation Mechanism.
-->In MYSQl , Normalization is the best example of Encapsulation.
-->Each and every class in java is following encapsulated mechanism.
-->The Object in Encapuslated class is called as DTO(Data transfer object) or PLOJO(Plain old java object) or Data Model

Data Hiding(To work on Encapsulation) :- This can be achieved by the following three terminologies:
      - we need to stop the access.                --> private keyword
      - we should provide the modification option. --> setters method
      - we should provide the redability option.   --> getters method

Benefits of Encapsulation:-
---------------------------
-->Security
-->Maintainability
-->code Reusability
-->Modularity
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

Abstraction:- 
==============
-->Abstraction is the process of "Hiding the Implemetation" and "showing only essential information" to the users.
-->By Using "Interface" and "abstract" keywords  we can achieve Abstraction.
-->ATM machine is one of the best example of Abstraction.

Interface:-
------------
-->Interface is a keyword used to create interface types.
-->Interface is a blue print of class.
-->Interface is a SRS(service Requirement Specification) but not implementation.
-->Interface is a contract between client and developers.
-->For Interface we cannot create an object.
-->Interface can extends any number of interfaces where multiple inheritance is possible with interface.
-->If we want to Implement "interface methods" we must need to use "implements" keyword in classes.
-->In Interface there are no constructors.

why interface..?
--------------------
-->if we want 100% abstraction then we will go for interface concept.

There are three types of Interfaces:
--------------------------------------
1) Normal Interface:-
      --> up to 1.7 version:- A interface can contain "any number of abstract methods" + " static variables".
      --> From 1.8 version:- In Interface we can have "default methods" and "static methods".
                           why?   -->"default methods" will help "to acheive the Backward Compatibility".
                                  -->"default methods" can be override.
                           why?   -->"static methods" will help "to provide constant behavior for all implemeted classes"
                                  -->"static methods" cannot be override.(this is the difference between default and static).
                                  -->we cannot call static methods by using "reference varaibles" , we can call them by using "interface names".
      --> From 1.9 version:- In Interface we  can have "private methods".
                            why? -->"Private Methods" will help to remove duplication from default methods.
    example:- Collection, List, Map, Set.

2) Functional interface:-
      -->An Interface which conatins only one "Abstract Method" is called as Functional Interface.
   example:- Comparable, comparator.

3) Marker Interface:-
     -->An Interface which does not contain any methods is called as marker Interface.
  example:- cloneable, seralization, Random Access.


Abstract Class:-
----------------
-->Abstract is a keyword:
     -- we can use for methods for declaration but not for implementation.
     -- we can use for classes for not creating an object of that class. 

why we need "abstract class"...?
--------------------------------
-->Whenever we don't want to create an object for our class then we need to go for "abstract class".
-->if we need "100%" abstraction we need to go for "interface" but if we need "0 to 100 %"(10 or 20%) abstraction we need to go for "abstract class".

              abstarct class                                               interface
         ---------------------------                              -----------------------------
1)  Abstract class can have abstract and                         1)Interface can have only abstract methods, since java8 it can have default
    non-abstract methods.(regular,concrete)                         methods and static methods.
2)  Abstract class can have constructors.                        2)In Interface there no constructors.
3)  Abstract class does not support multiple inheritance.        3)Interface supports multiple inheritance.
4)  Abstract can have final, non-final, static and               4)Interface can only have static and final variables.
    non-static variables.
5) The "abstract" keyword is used to declare                     5)The "Interface" keyword is used to declare Interface.
   abstract class.
6) Data Members of a java abstract class are private,            6)Data Members of a java interface are public by default.
   protected,etc...

example:-
----------
Interface In1
10 abstract methods 

abstract class AB1 implements In1{
  //We are implementing all the 10 abstract methods in abstract class without functionalities and creating like dummy implementation.
  //These Methods are called as concrete methods.
}
class A1 extends AB1{
  2 methods
}
class A2 exteds AB1
{
  3 methods
}
class A3 extends AB1{
  4 methods
}

Note:-
--------
In Abstract class, we can have abstract methods, concrete methods, static and instance variables, regular methods, constructors.
If a class is "abstract" then we no need to have "abstract methods" but if our class contains "abstract methods" then that class must be a "abstract class".

Benifits of Abstraction:-
--------------------------
-->Security
-->flexibility
=================================================================================================================================================================
INHERITANCE:-
===================
why inheritance..?
----------------------
-->Whenever we are looking for "Reusability" then we will go for inheritance.

what is inheritance..?
-------------------------
-->Inheritance means "IS-A RelationShip" and also we will consider as "HAS-A RelationShip".
-->Getting Data members or properties from parent class to child class is the concept of Inheritance.

Where we use inheritance..?
------------------------------
-->Everywhere in java , without inheritance there is no single java program.

-->"extends" is the keyword used to achieve inheritance.
-->By using child class reference and child class object we can call both child class and parent class functionalities.
-->By using parent class reference and parent class object we can call only parent class functionalities but not child class.
-->By using parent class refrence and child class object we can call only parent class functionalities but not child class directly, where we 
   can call child class methods which are override.(upcasting)
-->Storing parent object and child reference is not possible in java because parent class is not extended by the child class.
 (Downcasting is not possible in java directly but with explicit type casting we can call both child and parent class functionalities)

Types of Inheritance:-
-----------------------
-->implicit inheritance
-->single level inheritance
-->multi level inheritance
-->multiple inheritance -->it is not possible in java for classes but it will be possible for ionterfaces.
-->Heirarchial inheritance
-->Hybrid inheritance
-->cyclic inheritance-->It is not possible in java.

1)Single Level Inheritance:-
----------------------------
               A(super class)
               |
               B(sub class)
example:-
class A{
}
class B extends A{
}

2)Multi Level Inheritance:-
-----------------------------
            A(super)
            |
            B(intermediate class)
            |
            c(sub)
example:-
class A{
}
class B extends A{
}
class c extends B{
}

3)Multiple Inhertiance :-
-----------------------
Multiple Inheritance is not possible in java for classes. It is possible for interfaces.
Example:-
class A{
}
class B{
}
class c extends B,A{
}

4)Heirarchial Inheritance:-
-----------------------------
      A(super)
      |
    -----
    |    |
    B    C -->sub classes

example:-
class A{
}
class B extends A{
}
clsss C extends A{
}

5)Hybrid Inheritance:-
-----------------------
-->It is a combination of two or more types of inheritance.
example:-

 interface A{
 }
 class B{
 }
 class C  implements A extends B{
 }

6)cyclic Inheritance:- It is not possible in java.

Benifits:-
----------
-->Code Reusability
-->Redability
-->Memory efficiency
=================================================================================================================================================================
POLYMORPHISM:-
==================
Why we need to go for polymorphism..?
--------------------------------------
    --Flexibility, redability or loosly coupling.

what is polymorphism:-
------------------------
-->polymorphism means "many forms" and it occurs when  we have many classes that are related to each other by inheritance.

-->We have two types of polymorphism they are:
   1)compile time polymorphism (or) Method Overloading (or) static polymorphism (or) Early Binding
   2)Run time polymorphism (or) Method Overriding (or) Dynamic Polymorphism (or) Late Binding

Method Overriding (or) RunTime polymorphism:-
----------------------------------------------
why method overriding..?
------------------------
 -->Whenever we are not happy or not satisfying with the parent class functionalities then we will gor for method Overriding.

what is Method overriding:-
---------------------------
A Method in parent class is declared with same name , arguments and return type agiain in child class then that is called as method overriding.


Method Overriding Rules:-
-------------------------
1)Method Signature(name+arguments but not return type) should be same.
2)Method return type must be same until 1.5 version, afterwards we have co-variant return types.
  Co-variant Return type:-
     -->Method return must be same if it is primitive datatype even after 1.5 version also.
     -->Method return no need to be same if it is object datatype after 1.5 version  we can use co-variant return type.
     -->Covariant return type means , If the  parent class return parent type then our child class can return the parent type or it's child type.
         example:-
             if Parent: Number --> Child : Number or it's sub types(Wrapper Object Datatypes)
3)Method Scope should not be reduced.
4)Parent class private methods , we cannot override them in child classes, if we write the "@Override" annotation or if we are not writing that annotation then the child class is considering it as a different method and there will be no error.
5)parent class final methods, we cannot override them in child classes.
6)Parent class static methods, we cannot override them in child classes when we are using "@Override" annotation but when we are not using that annotation then
  it is considered as Method Hiding.
7)If Parent class throws any exception then child class no need to throws the exception but if the child class throws any Exception then the parent class must throws that exception.
8)Parent abstract class abstract Methods , we must need to override them in Child classes.
9) Parent class regular methods or normal methods we can  override them as abstract methods in abstract child class.


Method OverLoading:-
---------------------
-->In  any class, if we have same methods with different types of arguments, then we can call it as Method Overloading.
Best Example:- Println() method from printStream Class.

Rules for Method Overloading:-
-------------------------------
Rule 1: Method Signature should not be same.
Rule 2: Method Return type is not a part of MOL, whether it is same return type or not.

Benefits of polymorphism:-
==========================
-->Flexibility
-->Loosely Coupling
-->Readability
================================================================================================================================================================
EXCEPTION HANDLING:-
======================
why we need to Handle Exceptions..?
------------------------------------
 -->For a Graceful or successful termination of a program or Application, we need to Handle Exceptions.

What is Exception?
------------------
-->Exception means a problem which will occur due to "Bad Logics or Bad Data".
-->Exception is an "Unwanted Event" that occurs in a Normal Flow and the program will terminate "abnormally".
-->The Best Example is Corona.
-->Exception is a Pre-defined Class under "Throwable class".
-->"Throwable" is the Parent class of two child classes("Exceptions" and "Errors") in java from java.lang package.
-->We can handle the Exceptions by using below keywords:
      -try
      -catch
      -finally
      -throw
      -throws

What is Error..?
-----------------
-->Error , which will Occur "Due to Lack of Resources".
-->We cannot handle the errors.
-->Example:- Virtual Machine error(OutOfMemoryError, StackOverFlowError).
-->compile time errors and errors are different.(compile time errors-->due to syntacticle mistakes, errors-->due to lack of resources.)


Types of Exceptions:
---------------------
There are two types of Exceptions, they are:
 1) Checked Exceptions:-
 ------------------------
   -All "Exception classes" under "Exception class" are checked Exceptions.
   -Any Exceptions which are checked by the compiler at compile time is called as Checked Exceptions.

   Examples:-
  -------------
    1)IOException
    2)FileNotException
    3)InterruptedException
    4)ClassNotFoundException
    5)SQLException
  

 2) Unchecked Exceptions.
----------------------------
   -All "Exception classes" under "RunTimeException" class are Unchecked Exceptions.
   -Any Exceptions which are not checked by the compiler at compile time is called as Unchecked Exceptions.

   Examples:-
  ------------
   1)ArithmeticException : If any Number divisible by Zero then we will get "ArithmeticException".
   2)NullPointerException : "null" with any operation is a Null pointer Exception.
   3)IndexOutOfBoundsException 
   4)ArrayIndexOutOfBoundsException : If we give size of an array more than expected then we will get "ArrayIndexOutOfBoundsException".
   5)StringOutOfBoundsException : If we try to access the index which is not available in String then we will get "StringOutOfBoundsException".
   6)InputMismatchException  : If we have declared input as Integer but we are giving String input in console then we will get "InputMissMatchException".

================================================================================================================================================================
COLLECTIONS IN JAVA:-
=====================
-->These provides below shown methods.
-->"Collections.sort(arr_name or list_name); " -->It is used to sort the elements of array or list.
-->"Collections.copy(arr1,arr2) ;" -->It is used to copy elements from one array to another array. 
-->"Collections.swap(arr,index1,index2);" --">It is used to swap elements of the array.
-->"Collections.reverse(arr);" -->It is used to reverse  elements of the array.
-->"Collections.frequency(arr,ele);"
-->"Collections.max(arr);" -->It is used to find maximum element of the array.
-->"Collections.min(arr);" -->It is used to find minimum element of the array.
-->"Collections.shuffle(arr);"  -->It will rearrange all the elements of the array.
-->"Collections.replaceAll(arr, old_value, new_value);"
-->"Collections.binarySearch(arr,ele);"
-->"Collections.rotate(arr,how_many_rotations);
so these are some the important methods they can be by using collections. 
=================================================================================================================================================================
COLLECTION FRAME WORK IN JAVA:-
==================================
-->Any Group of individual objects which are represented as a single unit known as collection of objects. In java, a seperate framework named as  "COLLECTION 
   FRAMEWORK" has been defined in java jdk1.2 which holds the collection classes and interfaces.
-->following are some of the collection data structures in java.
-->They are:-
        -->ArrayList
        -->LinkedList
        -->HashSet
        -->LinkedHashSet
        -->TreeSet
        -->HashMap
        -->LinkedHashMap
        -->TreeMap
JAVA ARRAYLIST:-
====================
-->The "ArrayList" class is a  resizable array which can be found in the java.util package.
-->The difference between  "built-in array" and "ArrayList" is that for the built array we cannot add or remove elements to/from the built-in array whereas for 
   ArrayList the elements can be added or removed at any place or position.
-->vector is a thread safe and ArrayList is not a thread safe.
-->mutable collection.
-->SYNTAX:-
      import java.util.ArrayList;
      List<data_type> Arraylist = new ArrayList<>();
                   or
      ArrayList<data_type> ArrayName = new ArrayList<data_type>();
-->SOME OF THE USEFUL METHODS THAT ARRAYLIST CLASS HAS:-
   -->"A.add(ele);"  -->it is used to add elements in to the arraylist.
   -->"A.add(index, ele);" -->it is used to add element at the specific position in the list.
   -->"A.addAll(newList);" --> it is used to addall elements of newList to the already existing ArrayList.
   -->"A.get(i);"  -->it is used to access elements inthe arraylist.
   -->"A.set(index, ele);" -->it is used to replace elements at particular position in the arraylist.
   -->"A.remove(index);" -->it is used to remove element at particular index in the arraylist.
   -->"A.indexOf(ele);" -->it will return index of the specific element.
   -->"A.clear();" -->it will entire arraylist.
   -->"A.size();" -->it will print size of the arraylist.
   -->"A.contains(ele);" -->it will checck for whether the element exits or not.and return true or false.
   -->"A.isEmpty();" -->it will true or false based on whether the ArrayList is empty or not.
   -->"A.endsWith("ch");"
   -->"A.startsWith("ch");"
-->for(String c : cars){
      if(c.endsWith("a")){
          System.out.println(c);
      }
      if(c.startsWith("V")){
         System.out.println(c);
      }
}
-->for(int i=0;i<A.size();i++){
    System.out.println(A.get(i));
 }
-->for(int x:A){
 system.out.println(x);
}
================================================================================================================================================================
JAVA LINKEDLIST:-
====================
-->java  LinkedList Class is same as Java ArrayList Class both are having same methods to perform operations.
-->The difference between ArrayList and LinkedList are insertion and deletion of elements are faster in LinkedList when compared to ArrayList.
-->mutable collection.
SYNTAX:-
========
import java.util.LinkedList;
List<data_type> linkedlist = new LinkeList<>();
          or
LinkedList<data_type> L = new LinkedList<data_type>();
-->Following are some of the useful methods that LinkedList has:-
     -->"L.add(ele);" 
     -->"L.add(index,ele);"
     -->"L.get(i);"  --->it is used to access the items in linked list.
     -->"L.size();"
     -->"L.set(i,ele);"   -->it is used to replace an item at the specific position inthe linkedlist.
     -->"L.remove(i);"    -->it is used to remove specific item in the linkedlist at specific position.
     -->"L.clear();"
     -->"L.contians(ele);"  -->return true or false .whether the element presento or not.
     -->"L.isEmpty();"       -->return true or false. whether it is empty or not.
     -->"L.addFirst(parameter);" -->adds an item to the beginning of the  list.
     -->"L.addLast(parameter);"  -->adds an item to the end of the list.
     -->"L.removeFirst();" -->removes an item from the begging of the list.
     -->"L.removeLast();" -->removes an item from the end of the list.
     -->"L.getFirst();" -->get an item at the beginning of the list.
     -->"L.getLast();" -->get an item at the end of the list.          ---->These two methods should be in print statements.
     -->"L.endsWith("ch");"
     -->"L.startsWith("ch");"
-->for(String c : cars){
      if(c.endsWith("a")){
          System.out.println(c);
      }
      if(c.startsWith("V")){
         System.out.println(c);
      }
}
================================================================================================================================================================
 JAVA HASHSET:-
==================
-->It is used to store collection of items where every item is unique and it can found in java.util package.
-->immutable collection.
-->It does not cares about sorted order and  insertion order.
SYNTAX:-
=======
import java.util.HashSet;
 Set<data_type> Hashset = new HashSet<>();
            or
 HashSet<data_type> HashSet_Name = new HashSet<data_type>();

-->Following are some of the useful methods that HashSet has:-
     -->"HashSet_Name.add(ele);" --> it is used to add elements in to the Hashset without caring about insertion and sorted order.
     -->"HashSet_Name.addAll(newSet);"
     -->"HashSet_Name.Contains(ele);" -->it will check whether the element present in the set or not.
     -->"HashSet_Name.size();" -->it will return size of the set.
     -->"HashSet_Name.clear();" -->it will delete entire set at a time.
     -->"HashSet_Name.remove(ele);" -->it will remove specific element in the HashSet.
     -->"HashSet_Name.isEmpty();" -->return true or false  based on whether the HashSet is empty or not.
-->for(int i : HashSet_Name) {
         System.out.println(i);
    }
=================================================================================================================================================================
JAVA TREESET:-
====================
-->TreeSet cares about sorted Order but not about insertion order.
-->HashSet does not cares about both sorted and insertion order.
-->LinkedHashSet cares about insertion order but not about sorted order.
SYNTAX:-
========
Set<data_type> numbers = new TreeSet<>();
      or
TreeSet<data_type> treeset = new TreeSet<data_type>();
-->"numbers.add(ele);" -->it will add  items into the set in sorted order without caring about insertion order.
-->"numbers.floor(ele);" -->it will return the element that is less than or equal to the given parameter.
-->"numbers.lower(ele);" -->it will return the element that is less than the given parameter.
-->"numbers.ceil(ele);" -->it will the return the element that is greater than or equal to the given parameter.
-->"numbers.higher(ele);" -->it will the return the element that is greater than the given parameter.
-->"numbers.subSet(ele1, ele2);" -->ex: [10,12,14,15,17, 18,20,24,26] -->numbers.subSet(15,20); -->[17,18]
-->"numbers.headSet(ele);" -->it will return the elements that are before to the given parameter.
-->"numbers.tailSet(ele);" -->it will return the elements that are after to the given parameter.
=================================================================================================================================================================
PRIORITY QUEUE:-
=================
SYNTAX:-
==========
Queue<Data_type> q = new priorityQueue<data_type>();
-->"q.addAll(newList);" -->it is used to add list of items in to the list.
-->"q.offer(ele);" --->it is used to add element/item in to the queue.
-->"q.poll();"     --->it is used to bring out elements from the queue.
-->"q.remove();"
-->"q.peek();"
===============================================================================================================================================================
JAVA MAP:-
=================
-->MAP stores items or elements as key value pairs.
-->it does not allows duplicates.
-->"HashMap" -->it is unsorted and unordered.
-->"LinkedHashMap" -->it maintains or cares about insertion order.
-->"TreeMap" -->it maintains or cares about sorted order.
SYNTAXES:-
================
-->Map<key,value> map= Map.of("A" , 1 , "B" , 2, "c" , 3);
-->"HashMap<key, value > map = new HashMap<>();"
-->"LinkedHashMap<key,value> map1 = new LinkedHashMap<>();"
-->"TreeMap<key,value> map2 = new TreeMap<>();"
Following are some of the useful methods that MAP has:-
-->"map.put(key,value);" -->it is used to insert key and values into the map.
-->"map.get(key);" -->it is used to access value by using key.
-->"map.size();" -->it will return size of map.
-->"map.clear(); " -->it will delete entire map.
-->"map.isEmpty();" -->it will return true or false based on whether map is empty or not.
-->"map.containsKey(key);" -->it will return true or false.
-->"map.containsValue(value); " -->it will return true or false.
-->"map.remove(key);" -->it is used to remove specific value in the map.
-->"map2.higherkey(key);" --> it will print the key that is greater than the given key.
-->"map2.ceilingKey(key);" --> it will print the key that is grater than or equal to the given key.
-->"map2.lowerKey(key);"  -->it will print the key that is less than the given key.
-->"map2.floorKey(key);"  -->it will print the key that is less than or equal to the given key.
-->"map2.firstEntry();"   -->it will print the first key in the map.
-->"map2.lastEntry();"    -->it will print the last key or entry in the map.
-->"map2.subMap("key1-range" , "key2-range");" -->it will print the subMap of the gievn range.
-->for(data_type c : map.keySet()){
     System.out.println(c); -->it will print all the keys of a map.
  }
-->for(data_type c : map.values()){
        System.out.println( c); -->it will print all the values in a map.
   }
-->To access elements of array into map use the following process:
      for(int i=0;i<A.size();i++){
             m.put(key, m.getOrDefault(key,0)+1);
      }
-->To print Keys ina map by using the map values use the foolowing logic:
 for (Map.Entry<Integer, Integer> entry : m.entrySet()) {
            if (entry.getValue().equals(cnt)) {
                a.add(entry.getKey());
            }
        }
================================================================================================================================================================
JAVA ITERATOR:-
===================
-->java "Iterator" is an object that can be used to loop through collections like "ArrayList" and "HashSet". It is called an iterator because iterating is the technical term for looping.
-->Syntax for creating iterator:-
 ====================================
import java.util.Iterator;
Iterator<data_type> it = Collection_name.iterator();
Example:-
========
import java.util.ArrayList;
import java.util.Iterator;
public class Iterating{
    public static void main(String args[]){
          ArrayList<Integer> A = new ArrayList<>();
          A.add(1); 
          A.add(10);
          A.add(14);
          A.add(16);
          A.add(18);
         //get the iterator
         Iterator<Integer> it = A.iterator();
         //prints the first term
         System.out.println("it.next()");
        //looping through iterator.
        while("it.hasNext()"){
             System.out.println(it.next());
        }
        while(it.hasNext()){
            Integer i = it.next();
            if(i< 10){
               "it.remove();"  //remove items from arraylist or collection by using iterator
            }
       }
      System.out.println(A);
 }
}
================================================================================================================================================================
JAVA CHAPTER 1 INTERVIEW QUESTIONS:-
=====================================
-->Why u choose java and what are the features of java?
-->what is the difference c/C++ and java?
-->what is the difference b/w static and dynamic memory allocation?
-->difference b/w class and object?
-->what is the difference b/w source code, byte code , binary code or machine level code?
-->what is the difference static v/s Instance data members?
-->what are the different types of Class loaders?
-->what are the different memory managements in JVM?
-->what is the difference b/w interpreter and JIT?
-->Explain About Garbage Collection how can we achieve this?
-->Explain about main method why need to have in java?
-->Difference between Static Blocks and instance Blocks.
