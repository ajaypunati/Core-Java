JAVA INTORDUCTION:-
=====================
Definition of Java:-
====================
-->java is a simple , High-level, secure,platform independent,Robust,Dynamic , Multi threading and Object oriented programming language used for developing Both 
   Standalone and Web(internet) Applications.
-->java is case sensitive programming language.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
How Java Started:-
===================
-->In 1990, sun microsystems began a new project known as the Green project to work on a new Technology.
-->java was developed by or brainchild of  James gosling and his team(patrick Naughthon,Mike sherdin) at sun micro Systems in 1991.
-->intitally java named as "GreenTalk" later on it is renamed as "oak" .
-->"oak" is renamed as java in the year 1995 where java was first publicy released and later acquired by oracle corporation.
-->In 1996 java Development kit(JDK)1.0 was released.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
WHY JAVA:-
===========
-->Java Programming language is Invented for Developing Internet Applications by providing Platform independence(Write once run anywhere).
-->Java is one of the most popular programming language in the world.
-->It has more demand in the current job market.
-->it is easy to learn and simple to use.
=================================================================================================================================================================
JAVA PROGRAM STEP BY STEP EXECUTION PROCESS:-
===============================================
-->Step-1:  create a java source code file with .java extension
-->step-2:  compile the source code using the java compiler which will creates a bytecode file with .class extension.
-->Step-3:  class loader reads both user defined and library classes into memory for execution.
-->step-4:  bytecode verifier validates all the byte codes are valid.
-->step-5:  jvm(java virtual machine) reads bytecodes and translate into machine Level Language for execution. 
-->jvm is a interpreter which converts bytecode to machine code or machine specific instructions.
-->"JVM" stands for Java Virtual Machine it is a Java interpreter. It is responsible for loading, verifying, and executing the bytecode created in Java.
-->"JRE" stands for Java Run-Time Environment, it is an installed package that provides environment and libraries and other components to run applets and java programming Applications.
-->"JDK" (JDK=JRE+JVM)stands for Java Development Kit which provides the environment to develop and execute the java programs.
=================================================================================================================================================================
JVM ARCHITECTURE:-
===========================
Why do we need JVM:-
--------------------
-->Operating System is not provided environment to execute java Applications or programs.
-->To excute java programs or Applications we must need  to have JVM.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
what is JVM? -->JVM is a interpreter which is responsible for loading,verifying and executing byte code created in java.
-->".Class" file is the input to the JVM.
ARCHITECTURE:-
--------------
".class"--> 1)Class Loader Subsystem:
                 -->Loading(Classes will be loaded by this Component)
                      -->Bootstrap Class Loader -->Responsible for loading classes find inthe "jre/lib .folder"
                      -->Extension Class Loader -->ResPonsible for loading Classes find inthe "jre/lib/ext.folder"
                      -->Application Class Loader -->Responsible for loading Application-level class path,path mentioned in environment variable,etc.
                             |
                           CLASS NOT FOUND EXCEPTION
                 -->Linking
                      -->verify -->Bytecode verifier will verify whether the generated bytecode is proper or not.
                      -->Prepare -->For all static variables memory will be allocated and assigned with default values.
                      -->Resolve -->All symbolic memory references are replaced with original references from Method Area.
                -->Intialization -->we assign original values to the static varibales and static blocks get executed.
             2)Memory management or Run time Data Area:
                  -->Method Area
                       -->The "Method Area" is Loading Class Level Data.
                       -->All the static Data will be stored in 'Method Area".
                  -->Heap Area
                       -->The "Heap Area" is Loading Object Level Data.
                       -->All the Instance data Will be Stored in "Heap Area".
                  -->Stack Area
                        -->Executing the method When we Called is happening inside the Stack Area, When Main  method and all other methods after completing 
                            execution will be removed from Stack Area.
                  -->PC Registers -->They will hold the address of the current executing instruction once execution is completed they will updated with next 
                                      instruction.
                  -->Native Method Stack -->native method stack holds the native method area information.
              3)Execution Engine
                   -->Interpreter 
                         -->Converts byte Code into machine level language to excecute.
                   -->JIT(Just-In-Time) Compiler : suppose if we call a method for many times in main method then the jvm will go to the interpreter only once 
                     and remaining time the JIT Compiler  will take care of it , that is the use of JIT(i.e used for better performance of Java Apllications 
                     during runtime). 
                   -->Garbage Collection:
                        -->This garbage Collection can be done in two ways:
                            -->By Making the refernce variable as "NULL"ify(t=NULL), and assigning one reference variable to other(t1=t).When we use any one of 
                               the above mehtod we need to call garbage Collector(System.gc()) then the Garbage Collector will Call the Finalize() method and it 
                               will remove garbage value or nullify value from the memory.
              4)Native Method Libraries  --
                                            |--> Any logic that  written in other lanaguage can access in java by using this native method lib and interfaces. 
              4)Native Method Interface  --
=================================================================================================================================================================
APPLICATIONS OF JAVA:-
==========================
  -->java is used in "DESKTOP APPLICATIONS"
  -->"MOBILE APPLICATIONS"
  -->"ENTERPRISE APPLICATIONS"
  -->"WEB APPLICATIONS"
  -->"EMBEDDED SYSTEMS"
  -->"GAMING".
=================================================================================================================================================================
ADVANTAGES OF JAVA:-
==============================
-->java  is a popular and widely used programming language with many advantages.
     -->platform independent -->code can run on any jvm installed desktop
     -->object-oriented programming -->deals the data with objects
     -->Simple
     -->Secure
     -->High-performance
     -->memory management
     -->multi-threading
     -->community support
     -->Dynamic
     -->Distrobuted.
     -->Robust-->Garbage Collection and exception handling makes the java programming as Robust.
     -->Architecture Neutral -->it is not depend on the Architecture design.
=================================================================================================================================================================
-->What is meant by "public static void main(String args[])"?
     -->In public static void main(String args[])
              -->public means direct access to the jvm(Java virtual machine).
              -->static means direct access to the jvm(Java virtual machine)  but without creating any object.
              -->void means where as main function does not return anything.
              -->main means, it is callable environment to the java programs  where we can call user defined and pre-defined functions.
              -->As we taking String args[] as arugment it accepts any type of any number of arguments.
=================================================================================================================================================================
DIFFERENCE BETWEEN C++ AND JAVA:-
=======================================================
--> C++                                                                JAVA
   ======================                                       =====================================
    1.It is plat-form dependent                                    1.It is plat-from Independent
    2.It is mainly used for system programming                     2.It is mainly useful for application programming
    3.It supports goto statement                                   3.It doesn't supports goto statements
    4.It suports multiple inheritance                              4.It doesn't supports multiple inheritance through class. It is acheived through interfaces.
    5.It supports structures and unions                            5.java doesn't supports structures and unions.
    6.c++ supports pointers and we can write a pointer program     6.java does not supports pionters instead they developed references(address of the objects)
    7.c++ supoorts operator overloading                            7.java doesn't supports operator overloading.
=================================================================================================================================================================
PACKAGES IN JAVA:-
=====================
-->Package in java can be defined as grouping related type of classes & interfaces.
-->packages are used to avoid naming clashes and provides easier control access.
-->It is easier to locate related type classes using Packages.
-->There are two typesof packages in java they are -->user defined and built in packages.
=================================================================================================================================================================
WHAT A CLASS CAN CONTAIN:-
==========================
1) Data Members:
        -->Static Datamembers(variables+Methods)
        -->instance DataMembers(Variables+Methods)
2)Blocks:
    -->Static Blocks
    -->Instance Blocks
3)Constructors:
      -->default
      -->Parametrized Constructor
4)Interfaces
5)Inner Classes
----------------------------------------------------------------------------------------------------------------------------------------------------------------
CLASS:-
=======
-->Class is a Blue Print of an object or it is a Template.
-->We can call class as a user defined data type.
-->By Default class extends from Object in java.
OBJECT:-
=========
-->An Instance of a class is called an object.
-->Object is a Dynamic Memory Allocation.
-->Object is a real time entity.
-->Object consists of state , behaviour and Indentity.
Note: Where as Class is Dummy and Object is Real.
-->The Java Compiler will provide default constructor for your class to create an object.
creating object:-
-----------------
-->ClassName A = new ClassName();
          or
    new ClassName();
=================================================================================================================================================================
READING INPUT IN JAVA:-
========================
Scanner class:- Scanner Class is a predefined class in "java.util" package
  -->Scanner sc=new Scanner(System.in); 
     byte r   =sc.nextByte();
     short m  =sc.nextShort();
     int n    =sc.nextInt();
     long s   =sc.nextLong();
     double w =sc.nextDouble();
     float f  =sc.nextFloat();
     String q =sc.nextLine(); or sc.next();
     Char ch  =sc.next().charAt(0 or i);
BufferedReader class:-
    -->InputStreamReader s=new InputStreamReader(System.in);
    -->BufferedReader br=new BufferedReader(s);
       ---->int n = Integer.parseInt(br.readLine());
       --->float f= Float.parseFloat(br.redLine());
=================================================================================================================================================================
-->To find Number of digits in the given number use this logic: (int)Math.log10(num)+1;
-->TO seperate the digits from first then use the below logic:
        while(num>0)
        {
           int r= num/(int)Math.pow(10,d) ;
           num=num%(int)Math.pow(10,d);
        }
=================================================================================================================================================================
PRINTING OUTPUT:-
==============================
-->there are 3 ways of printing output.
-->1.System.out.println("HELLO WORLD");
-->2.System.out.print(x);
-->3.System.out.printf("THE VALUE OF x IS :"+x);
-->"System" is a prdefined Class, "Out" is a static variabel in System Class and refering PrintStream Class, "println()" is a Method in printStream Class.
-->while printing the floating point numbers after decimal point print only 2 digits.
float pi=3.142345f;
System.out.println(pi);
-->Formating the output:-
System.out.format("%.2f",pi);
System.out.printf("%.2f",pi);
=================================================================================================================================================================
"JAVA LANGUAGE FUNDAMENTALS":-
============================================================
JAVA IDENTIFIERS:-
============================
-->java identifiers are used for indentification purpose (or) Any name of the Project, package,class,interface, Method,variable is called as Identifier.
-->valid identifiers:-->($,_,[A-Z],[a-z],[0-9])-->but should not start with numbers.
-->Invalid identifiers:-->(@,#,%,-,...)
  RULES FOR IDENTIFIERS:-
 =====================================================================
   1)Java Identifiers can use (a-z) or (A-Z) or (0 - 9).
   2)Java Identifiers should not start with numeric values(0 -9)(Sysntax error at token 1).
   3)Java Identifiers should not contain any Special Characters except "_" and  "$" , we can start identifers with "_" or "$".
   4)Java Identifiers should not be a Java Keywords.
=================================================================================================================================================================
JAVA KEYWORDS:-
==================
"Primitive Datatypes(8), Apllication level or oops(14), Access Modifiers(12), Exception handling(5), Logical Satatement(11)"
PRIMITIVE DATATYPES KEYWORDS:-
-------------------------------
For Reprsenting The Numbers:
  -->byte
  -->short
  -->int
  -->long
------------------------------------------
For Reprsenting floating Decimals:
  ->float
  ->double
----------------------------------------------------------
For Representing charcters and true or false conditions:
  ->char
  ->boolean
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
APPLICATION LEVEL (OR) OOPS KEYWORDS:-
---------------------------------------
 -->"package" :- package is a keyword to create package for collection of classes and interfaces.
 -->"import"  :- To import classes or interfaces or enums  from one package to another package.
---------------------------------------------------------------------------------------------------
 -->"class"    :- Class is a blue print of an object or template or user defined datatype.
 -->"interface":- interface is Blueprint of a class. 
 -->"enum"     :- To represent constant values we use enum like a class.
 -->"new"      :- new keyword is used to create object for a class.
 -->"instanceof" --> to check status of the object from another object.
---------------------------------------------------------------------------------------------------
-->"void" -->return nothing
-->"int"  -->return something in a method based on the return type.
--------------------------------------------------------------------------------------------------
-->"this" :-> this Keyword is used "To invoke current object data members".
-->"super" :-> super keyword is used "To invoke super object data members".
-->"implements" 
-->"extends"
-->"assert"
----------------------------------------------------------------------------------------------------------------------------------------------------------------
ACCESS MODIFIERS KEYWORDS(12):-
--------------------------------
-->"private" :-  priavte is a keyword, we cannot  use for a class but we can use inside the class.(The Scope of private is within  the class).
-->"<default>" :- The Scope of default is wihtin the package.
-->"protected" :- protected is a keyword , we cannot use for a class but we can use inside the class.(The Scope of Protected is "within the package + outside of the packages of subclasses:).
-->"public" :- public is a keyword we can user for a class and also we can use inside the class. (The Scope of public is within the project Anywhere).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-->"abstract" :-  abstract is a keyword for achieving  abstraction.
-->"static"   :-  static is a keyword we can use for data members and blocks. 
                  if we use static for a variable or data then it is constant for all objects.
                  if we use static for a method or blocks then it will loading to  the memory without creating object.
-->"strictfp" :-  strictly follow floating point data in all the systems.
-->"synchronized" 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-->"final" :-  final is for class then we cannot extends that class.
               final is for method then we cannot override that method in child class.
               final is for varaible then we cannot change the value.
-->"transient"(only for varaibles)
-->"Volatile" :- volatile means keep on changing , we can use it in multithreading when the threads are sleeping still you want to make your variables to change  the values.
-->"native"
----------------------------------------------------------------------------------------------------------------------------------------------------------------
EXCEPTION HANDLING(5):-
------------------------
-->try
-->catch
-->finally
-->throw , throws
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
LOGICAL STATEMENT:-
--------------------
-->if
-->else
-->for
-->while
-->do while
-->switch 
-->case
-->continue
-->goto
-->const
=================================================================================================================================================================
JAVA ACCESS MODIFIERS/SPECIFIERS:-
====================================
-->"private"   :- priavte is a keyword, we cannot  use for a class but we can use inside the class.(The Scope of private is within  the class).
-->"<default>" :- The Scope of default is wihtin the package.
-->"protected" :- protected is a keyword , we cannot use for a class but we can use inside the class.(The Scope of Protected is "within the package + outside of 
                  the packages of subclasses:).
-->"public"    :- public is a keyword we can user for a class and also we can use inside the class. (The Scope of public is within the project Anywhere).
-->"final"     :- final is for class then we cannot extend the classs.
                  final is for method then we cannot override that method in child class.
                  final is for variable then we cannot change the value of that variable.
-->"static"    :- static is a keyword we can use for data members and blocks. 
                  if we use static for a varaible or data then it is constant for all objects.
                  if we use static for a method or block then it will loading to the memory wihtout creating object.
                  static data remains constant for every object but instance data varies for object to object.
================================================================================================================================================================
JAVA  DATATYPES:-
=======================================
-->There are Two types of Data types in java : they are "Primitive Data types " and "Non-primitive datatypes"
-->Primitive data_types in java are pre-defined by a java language and named as the reserved keywords. As primitive data_types does not share a state with other primitive values. The Data in data types is stored in a 2's complement way. ( -2^n to 2^n-1)
-->byte (Byte)        ->size->1byte(8 bits)-->max value we can store in byte is 127 and min value is -128 -->byte bytevar;
                                                                                                (Byte.SIZE,Byte.MAX_VALUE,Byte.MIN_VALUE);
-->short(Short)       ->size->2bytes(16 bits)-->max value we can store in short is 32767 and min value is -32768 -->short shortvar; 
                                                                                                (Short.SIZE,Short.MAX_VALUE,Short.MIN_VALUE)
-->int(Integer)      ->size->4bytes(32 bits) -->max value we can store in int is 214748 and min value is -2147483647 -->int intvar; 
                                                                                                (Integer.SIZE,Integer.MAX_VALUE,Integer.MIN_VALUE)
-->long(Long)        ->size->8bytes(64-bits)-->long longvar;          
                                                                                                (Long.SIZE, Long.MAX_VALUE,LONG.MIN_VALUE)                                       
-->float(Float)      ->size->4bytes(32 bits)-->float floatvar;
                                                                                                (Float.size(), Float.MAX_VALUE,Float.MIN_VALUE)
-->double(Double)    ->size->8bytes(64 bits)-->double doublevar;
                                                                                                (Double.size(), Double.MAX_VALUE,Double.MIN_VALUE)
-->boolean           ->size->1bit  -->boolean boolvar;
-->char              ->size->16-bits-->char charvar; ( 0 to 65535) -->char data types is a single 16-bit unicode characters.
-->All integers can be characters(bythe concept of ASCII Values) and all Characters can be a integers.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Non-Prirmitive Data types(Wrapped object data types, pre-defined object data types, user-defined object data types):-
====================================================================================================================
-->String        
-->StringBuffer   
-->Math
-->BigInteger 
      -->It is a predefined class and predefined object datatype , it can store value larger than "int" and "long".
      -->synatx:-  BigInteger b= new BigInteger("232097329209027598383833793830383");
                   BigInteger b1= new BigInteger("2320973292090275983834865484646438463830383");
      -->Following are some the methods that BigInteger have:
              -->b.add(b1);
              -->b.multiply(b1);
-->BigDecimal
       -->BigDecimal b2=new BigDecimal("467686969670707.6868686868");
-->Student,Employee,Address,....(user-defined object datatypes)
-->"NULL" is the Default value of any object data type.
=================================================================================================================================================================
JAVA TYPECASTING:-
====================
-->Type casting is nothing but when we assign a value of one primitive data_type to another data_type.
-->there are two typesof type casting they are:
      1.Widening type casting(Automatic) :-  converts smaller data_type to larger data_type size. 
         byte -> short -> char -> int -> long -> float -> double.
      2.Narrowing type casting(Manual) :- converts  larger data_type to smaller data_type size
         double -> float -> long -> int -> char -> short -> byte.
-->Example for automatic or widening :-
          int myInt = 9;
          int mydouble = myInt; -->this is nothing but implicit casting.
-->Example for manual or narrowing:-
          int myDouble = 9.0;
          int myInt = (int)myDouble; -->this is nothing but explicit casting.
================================================================================================================================================================
JAVA WRAPPER CLASSES:-
=======================
-->Java Wrapper classes provides a way to use primitive data_types as objects.
--->  Primitive data_type                Wrapper Oject Data Types
     ========================          ==============================
       byte(8bits)              -->      Byte
       short(16 bits)           -->      Short
       int(32 bits)             -->      Integer
       long(64 bits)            -->      Long
       float(16 bits)           -->      Float
       double(32 bits)          -->      Double
       char                     -->      Character
       boolean(1 bit)           -->      Boolean
-->example:
   =======
    import java.util.*;
    public class M{
        public static void main(String args[]){
                Integer a = 5;
                Float f = 5.66;
                Character c = 'A';
           System.out.println(a);
           System.out.println(f);
           System.out.println(c);
       }
   }
-->For converting one primitive data_type to another data_type we have type casting but to one type to another type by using wrapper class objects we have folowing methods.
     -->byteValue();
     -->shortVAlue();
     -->intValue();
     -->longvalue();
     -->floatvalue();
     -->doubleValue();
     -->charValue();
     -->toString();
-->example:-
  ==========
  import java.util.*;
    public class M{
        public static void main(String args[]){
                Integer a = 5;
                Float f = 5.66;
                Character c = 'A';
           System.out.println(a);
           System.out.println(f);
           System.out.println(c);
           System.out.println(f.intValue());
           System.out.println(a.doubleValue());
          System.out.println)(c.toString());
       }
   }
================================================================================================================================================================
JAVA LITERALS:-
=================
-->Literal is a Constant value which we are storing it into a varaibles.
-->Java Language Specifies Five Major types of literals,they are:
       --Integral Literals
             --Decimal Literals (Decimal Numbers starts  as a normal number and its range is 0 to 9)
             --octa Decimal Literals(Octa Decimal Numbers prefixed with "0")(range 0 to 8)
             --Hexa Decimal Literals(Hexa Decimal Numbers prefixed with "0X" or "0x") (range 0 to 9, a to f)
       --Floating Literals -->ocat and hex decimal literals are not possible for double datatype.
       --char Literals -->char data types is a single 16-bit unicode characters.
       --boolean Literals -->(true or false)
       --null literals -->most of the object reference varaibles are assigned with null vaue.
       --String Literals
-->Literals can be any Number  or texr or other information that represents a value.
-->We will use Literals in addition to variables in java  statements.
=================================================================================================================================================================
TYPES OF VARIABLES:-
=====================
-->DIVISION 1:-
--------------
   -->Based on type of value represented by a variable all variables are divide into two types:
          "Primitive variables" : can be used to represent primitive values.
          "object variables"    : can be used to refer to objects.
---------------------------------------------------------------------------------------------------
-->DIVISION 2:-
---------------
   -->Based on behavior and position of declaration all variable are divided into three types :
        1) "Instance variables" :
             -->The value of Instance variables varies from object to object.
             -->For every object a separate copy of Instance variable will be created.
             -->Instance variable will be created at the time of object creation and destroyed at the time of object destruction.
             -->Instance variables will be loaded in to the Heap Area when object is created.
        2) "Static Variables" :
              -->The Value of Static variables will be remain constant for all objects.
              -->For Any object , only one copy of static variable will be created.
              -->Static variables will be created at class level and loaded in to the method Area.
        3) "Local Variables" :
              -->The Local variables will be created inside the main method.
              -->Duplicates can be allowed to this variables.
              -->JVM is Not responsible for loading these local variables.
-->Compared to staic , instance and local , the highest priority will be given to local varaibles.
=================================================================================================================================================================
TYPES OF METHODS:-
====================
-->Method means it's a behaviour of a class.
                or
-->Method means Collection of logics and collection of statements.
                or
-->Method is a block of code which execute when we called.
-->We cannot write one method inside another method.
-->we can write a block inside of the Any Method.
-->The main aim of creating methods is to reuse the code any number of times.
-->There are 4 types of methods they are:
    -->Method with no "return type" and with "no arguments".
    -->method with "return type" and with "no arguements".
    -->method with "no return type" and with "arguements".
    -->method with "return type" and with "arguements".
Example Program:-
====================
package com.sample;
import java.util.Scanner;
public class TypesofMethods4 {
     static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		TypesofMethods4 t = new TypesofMethods4();
		t.m();
		t.m1(10,20);
		int age = t.m2();
		int sum= t.m3(2333, 333);
       //t.m3(int x=2, int y=3) --->We cannot pass arguements in this way -->it will give token error.
		System.out.println("my Age is:"+age);
		System.out.println("my sum is:"+age);
        
	}
	
	void m()   //With "No return Type" and with "No arguments"
	{
		System.out.println("Hai Ajay");
	}
	 
	void m1(int x , float y) {    //method with "no return type" and "with arguments"
		System.out.println("Sum of two Numbers is:"+(x+y));
		
	}
	
	int m2() //method "with return type" and "with no arguments"
	{
		System.out.println("enter your age:");
	  int age = sc.nextInt();
	  return age;
	}
	
	int m3(int x, int y) //method "with return type" and "with arguments"
	{
		return x+y;
	}

}
=================================================================================================================================================================
JAVA CONSTRUCTORS:-
=====================
Whay We need Constructors..?
---------------------------------------------------------------------------------------------------------------------------------------------------------------
     -->To Initializing an object and initializing instance data but not static data  we need Constructor.
     -->Without Constructor there is no chance to create the object.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Constructor..?
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-->Constructor is a special member function which is used to intialize objects.when Object is created constructor get invoked Automatically.
-->The class name and constructor name should be same.
-->constructors can be overLoaded.
-->Constructors doesn't return any values.
-->Constructors does not have any return datatypes even Void.
-->Constructors shuold be declared under public section.
-----------------------------------------------------------------------------
What are the types of Constructor types:
-----------------------------------------
-->Default Constructor:-
      -->why?--> If in our class we don't have any constructor(no-args,parameterized) then "java compiler" will create a Constructor that is called as "default 
           Constructor".
-->No-arg Constructor:-
      -->why?--> If in a class we are having a paramterized constructor then the java compiler will not create or call any default constructor so that to create 
         an object with no args we will go for the No-args Constructor. 
-->Parameterised Constructor:-
      -->why?-->While Creating an object, if we want to  send any  values to that object then we can go for the parameterized constructor.
-->"this" keyword is used to invoke current class object data members and to maintian the "code redability".
-->"this()" method is used to call current class Constructor. It cannot be used in a method, and this should be used only inside the constructor and written at 
    first line.
-->"super" keyword is used to invoke super class  object data members.
-->"super()" method is used to call super class constructor.
-->constructor Chaining
       -->If we are calling  one constructor into another constructor by using "this()"(incase of single class) and "super()"(incase of multiple classes) 
         methods is known as constructor chaining. 
-->Copy Constructor
       -->if we are copying one constructor into another constructor by using object reference variable.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
RULES FOR CONSTRUCTORS:-
----------------------------
1)Class name and Constructor name must be same.
2)Constructors should not return anything not even void.
3)Applicable modifiers for constructors as below: 
    -->private
    --><default>
    -->protected,public 
  Note:otherthan the above modifiers if we give any other modifiers then we will get the compile time error.
4)"this()" and "super()" must be in the first line of any constructor.
5)"this()" and "super()" must need to be call in constructor only but not in methods.
6)If we didn't create any constructor for a class , java compiler will create a default constructor.
7)If we have any constructor in our class then java compiler does not create any default constructor.
8)If we have parameterized constructor and we need to create an object with no values then we need to go for the no args constructor.
9)"this" and "super" keywords can used in both methods and constructors but not used in static methods.
10)In java ,constructor overloading is possible.
11)In one Constructor, we cannot call both this() and super().
12)The scope of "default constructor" is the "scope of class".
================================================================================================================================================================
ESCAPE SEQUENCES:-
==================
single quote ---> ' '
double quote ---> " "
new line     ---> \n
tab space    ---> \t
carriage return --> \r
Form Feed    ---> \f
backspace    ---> \b
backslash    ---> \\
-->While loop is called entry Controlled Loop or sentinel Loop and Do while loop is called exit controlled loop.
=================================================================================================================================================================
JAVA OPERATORS:-
===================
-->Binary Arithmetic Operators:-(+,-,*,%,/)
-->unary  Arithmetic  operators:-(-,+,++(pre,post),--(pre,post));
-->Relational opeartors:-(>,<,>=,<=,==,!=)
-->Logical operators:-(&&,||,!)
-->Assignment operators:-(variable=value, = ,+=,-=,/=,*=,%=,&=,|=,^=,<<=,>>=)
-->Ternary operator:-(condition?if true:if false)
-->Bitwise operators:-(&,|,^,>>(right shift),<<(left shift))
     -->right shfiting is nothing division by 2 and left is nothing but multiplication by2.
-->Literals are used to store binary data or hexadecimal data or all type of binary values.
Operators Preceedence and Associativity:-
 ========================================
 1.unary operators have high preceedence(+,-,++,--)
 2.  (.) -->paranthesis are having Second highest priority.
 3. *,/,% -->are having third highest priority.
 4. +(Addition) , -(Subtraction) -->are having fourth highest priority.
If we have same preceedence operators in the equation:
  then for(*,/, %) the Associativity will be Left to Right.
  then for(+,-) the Associativity will be from Right to Left.
=================================================================================================================================================================
JAVA ARRAYS:-
=================
Why wee need Arrays?
----------------------
       -->structuring the data in a proper way from unstructured data.
       -->It is More Readable to maintain the code.
       -->To maintain continuous memory allocation.
----------------------------------------------------------------------------------------
What is Array?
--------------
 -->Array is an object.
 -->Array is a index based, collection of homogeneous data elements into a single unit with fixed size.
 -->Array is a fixed and mutable(i.e we can replace the value of a array element)
Array Creation:-(For Creating an array we need to follow four steps they are: Declaration, Creation, Intialization, Representation)
=================
1) Declaration
    --> int[] ages;
2)Creation
    ages = new int[n]; //n is the size and index is "0 to n-1"
   Note:while creating an array, we must specify the size.
3)Intialization
    ages[0] = 22;
    ages[1] = 23;
    ages[2] = 24;
    ages[3] = 25;
4)Representation.
    //for(Initialization; condition; incre/decre){}
    //Intialization : where you want to starts from : int i= 0
    //condition     : up to where u want to go ?: i<100
    //Increment     :  Initial values incremented by +1: i++
   for(int i=0;i<n;i++){
     System.out.println(ages[i]);
   }
-->The Maximum Range of Array is : Integer maximum value(2147483647).
-->We can create and intialize an array in a single line by using "{}".
//Reading the elements from console using scanner clas..
---> for(int i=0;i<size;i++){
       A[i] = sc.nextInt();
   }
//for-each loop or enhanced for loop
-->for(int i : A){
    System.out.println(i);
   }

2D Arrays:-
==============
Whenever you want to represent rows and columns we need to go for 2Dimensional arrays.
synatx:-
-->int[][] A = new int[3][3];
          (or)
-->int[] A[] = new int[3][3];
for(int i=0;i<A.length;i++){
  for(int j=0;j<A[i].length;j++){
     System.oout.println(A[i][j]);
  }
}
-->for(int[] n1 : A){ //for -each loop for 2D array.-->first convet 2D to 1D array and then 1D to normal Number.
      for(int n : n1){
         System.out.print(n+" ");
      }
  }


JAGGED ARRAY:-
===============
-->Array of Arrays is called as jagged array.
 synatx:-
  int[][] A = new int[2][];
   A[0] = new int[4];
   A[1] = new int[3];

Example program for prime Number:-
-----------------------------------
import java.util.Scanner;
public class M{
   public static void main(String args[]){
       scanner sc =new  Scanner(System.in);
       System.out.println("Enter the size:");
       int s = sc.nextInt();
       int[] A = new int[s];
       System.out.println("Plz enter the array elements:");
       for(int i=0;i<s;i++)
       {
             A[i]=sc.nextInt();
        }
        System.out.println("Prime Numbers for the Array are:");
        for(int i=0;i<s;i++){
          boolean flag = true;
          for(int j=2;j<A[i];j++){
                if(A[i]%j==0){
                    flag = false;
                    break;
                }
           }
           if(flag){
              System.out.println(A[i]);
           }
         }
   }
}
=================================================================================================================================================================
JAVA STRINGS:-
====================
-->Strings are the type of objects that can store the character of values. A string acts the same as an array of characters in Java.
-->String Objects are immutable in java.
    -->Immutable in the sense the Object cannot be modified or unchanagable.
-->Once String Object is Created its data or state can't be changed but new object will be created.
-->Syntax :-
      string literal:-(<String_type>  <string_variable> = <String_Sequence>)
          String s = "HELLO";
      String object :-
          String s = new String("HELLO");
-->byte[] b_arr={12,13,14,15,16};
   String s= new String(b_arr);
-->STRING METHODS:-
   ===========================================
    String s = "learm share any";
    1)String length:-
          "System.out.println(s.length());" --->returns the number of characters in the String.
    2)String concatenate:-
         "s1=s1.concat(s2);" -->used to concatenate the two strings
    3)String charAt:-
          "System.out.println(s.charAt(i));"  -->returns the character at the ith index.
    4)String Substring:-
         " System.out.println(s.substring(int i));"  -->returns the substring from the ith index to the end of string.
    5)String subString:-
         " System.out.println(s.substring(int i,int j));"  -->returns the substring from the ith index to j-1 index.
    6)int indexOf:-
          "System.out.println(s.indexOf(ch));"   -->Finding a index of character in String.
    7)int lastIndexOf:-
          "System.out.println(s.lastIndexOf("a"));" -->Finding last indexof character in the string.
    8)String toLowerCase():-
         " System.out.println(s.toLowerCase());"      -->returns all caharacters of the string to lower case.
    9)String toUppercase():-
          "System.out.println(s.toUpperCase());"      -->returns all characters of the string to Upper Case.
    10)String equals(another string):-
         " boolean res= s1.equals(s2);"       -->return true/false;
         "boolean res1= s1.equalsIgnoreCase(s2);" -->return true again.
         "s1.compareTo(s2);" -->Compares two strings lexicographically.
         "s1.comapreTo(s2);" -->compare two Strings lexicographically,ignoring case differences.
    11)String toCharArray():-
          "char[] s=str.toCharArray();"
    12)String replace(char old ,char new):-
           "System.out.println(s.replace("f" , "g"));"
    13)string split:-
          "s.split("\\s+");" s.split(","); // for example String[] s = s1.split(",");
    14)toString():-
        String s1 = s.toString() or Integer.toString();-->used to convert given content to the string.
        String res = Integer.toBinaryString(num);
    15) String trim():-
          string s1=s.trim();
    16) "Character.isDigit(ch);" -->it will return true or false based on it is digit or not.
    17) "Character.getNumericValue(ch);" 
    18) "Character.isUpperCase();"
    19) "Character.isLowerCase();"
    20) "Integer.valueOf(ele);"
    21) "String.valueOf(ele);"
    22) int sum = IntStream.range(ele1 , ele2).sum();
    23) IntStream.rangeClosed(ele1 , ele2)
             .filter(num->num%2==0)
             .foreach(System.out:println)
================================================================================================================================================================
STRING BUFFER && STRING BUILDER IN JAVA:-
=========================================================
-->String Buffer is a Class in java that represents a mutable sequence of Characters. It provides an alternative to the immutable string class by allowing you to modify the contents of a string without creating new object every time.
-->String buffer is used to protect threads.
-->where as String builder doesn't protect threads.
     -->StirngBufffer sb=new StringBuffer();
      methods:-
          String sb=new StringBuffer();
          sb.append("HELLO"); --->used to add ,insert strings at the end of the buffer.
          sb.delete(1,3);     --->used to delete the characters from the buffer.
          sb.reverse();        -->used to reverse the buffer.
          sb.insert(position,string);
          sb.replace(1,3,string);
=================================================================================================================================================================
JAVA MATH:-
=====================
import java.io.*;
-->Math.max(x,y); //returns the maximum value.
-->Math.min(x,y); //returns the minimum value.
-->Math.abs(x); //returns the absolute value.
-->(int)Math.random()*10; //return the random values.
===============================================================================================================================================================
ARRAYS CLASS:-
==================
  -->Arrays class is a built-in class in java that provides variuos utility methods for working with Arrays.
   Methods:-
        import java.uitl.Arrays;
        int[] Array={1,4,2,5,3,6,9};
       1) Arrays.sort(Array_name);   //sort the elements of the array in ascending order.
       2)int[] index=Arrays.binarySearch(Array_name,value); //search for specific element inthe array using binary search algorithm.
       3)boolean[] equal = Arrays.equals(Array1,Array2); //compares to Arrays for eqaulity.
       4)var list=Arrays.asList(Array_name);  //converts given array into the list.
       5)int[] copy=Arrays.copyOfRange(Array_name,value1,value2); //copies the specified range of Array elements to another Array.
       6)Arrays.fill(Array_name,value); //Fills specific value in to the array.
       7)Arrays.toString(Array_name)
==============================================================================================================================================================
JAVA RECURSION:-
====================
-->Recursion is the technique of making a function call itself. This Technique provides a way to break down complicated problems into simple problems which are easier to solve.
Example:-
  public class Main{
      public static void main(String args[]){
           Scanner s = new Scanner(System.in);
           int num=s.nextInt();
           int res= sum(num); 
          System.out.println(res);
     }
     public static int sum(int n){ 
          if(n>0){
               return n+sum(n-1);
          }
           else
            {
              return 0;
            }
     }
  }
================================================================================================================================================================
JAVA OOPS:-
============================
-->OOPs Stands for object oriented programming.
-->object-oriented programming is about creating objects that contains both data and Methods.
Advantgaes/why we use oops:-
===========================
-->oop is faster and easier to execute.
-->oop gives clear structure of program.
-->oop makes code easier to maintain and reusable.
-->oop provides security and high efficiency.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
Following are some object oriented Principles:-
   -->Encapsulation
   -->Inheritance
   -->Abstraction
   -->Polymorphism
=========================================
ENCAPSULATION:-
=======================
-->The meaning of "Encapsulation" , is to make sure that "Sensitive" data is hidden from users.To Acheive this we need to    
     ->declare calss variables or attributes as Private.
     ->provide public "set" and "get" methods to access and update the value of private variables.
                                   OR
-->The process of wrapping code and data together in to a single unit is called Encapsulation.
-->Types:  function encapsulation, calss encapsulation, member variable encapsulation
   example:-
  ===================
  public class Main{
       private String name;
       public String getName(){
           return name;
       }
      public String setName(String name){
          this.name = name;  //use this keyword
      } 
     public static void main(String args[]){
          Main myobj  = new Main();
          myobj.setName("ajay");
          System.out.println(myobj.getName());
      }
  }
-->Why Encapsulation?
 =============================
-->Better Control of calss Attributes or variables.
-->class attributes can be made red-only or write only.
-->Increases security of data.
-->Code Maintainance.
=================================================================================================================================================================
INHERITANCE:-
===================
-->It is possible to inherit attributes and Methods from one class to another class .
-->Inheritance is "is a" relationship .
-->Inheritance is grouped into two categeories:
       -->Super or base class :- (the class whose features are  inherited is known as Super Class or Parent Class)
       -->Derived or sub class:- (the class that inherits the other class is known as derived class or sub class)
--->why we use inheritance:->it is useful for  code reusability.
TYPES:-
=======
1.single-level inheritance :- One sub class is extends from super class.
===========================================================================
                               A(Baseclass)
                                 |
                               B(Derived class)
Example:-
===========
     class parent{
        public int x=2;
    }
    class child extends parent{
         public int y=5;
         public static void main(String args[]){
             child myobj= new child();
            System.out.println(myobj.x+" "+myobj.y);
        }
    }
-----------------------------------------------------------
2.Multilevel Inheritance:- one class is inherited from another class , which is already exteded from another class.
====================================================================================================================
                        A(Base class)
                         |
                        B(Intermediate class)
                         |
                        C(Derived class)
Example:-
============
   class parent1{
      public int x=2;
    }
    class child1 extends parent1{
        public int y=3;
    }
    class child2 extends child1 {
        public int z=8;
      public static void main(String args[]){
          child2 myobj = new child2();
         System.out.println(myobj.x+" "+myobj.y+" " + myobj.z);
       }
    }
-->heirarchial Inheritance:-(Two derived class and one parent class those two derived classes are extended from one base class)
==============================================================================================================================
                              A(Base Class)
                              |
                            -   -
                           |      |
                    B(Derived)    C(Derived)
Example:-
===========
-->class parent{
      }
  class child1 extends parent{
  }
  class child2 extends parent{
  }
  class Main{
     public static void main(String args[]){
            child1 obj1 = new child1();
            child2 obj2 = new child2();
      }
 }
=======================================================================================
  Hybrid inheritance and multiple inheritance can be achieved by java interfaces.
 -->Hybrid inheritance is the combination of two or more types of inheritances.
Advantages:-
===========
--->code reusability
--->Abstraction
--->Method overriding
--->class heirarchy
--->polymorphism 
========================================================================================================================================
ABSTRACTION:-
==========================================
-->Abstraction is the process of "hidding certain details" and "showing only essential information to the user."
-->Abstraction can be acheived with either abstract classes or interfaces.
-->Abstract class:- It is a restricted class that cannot be used to create objects(to access it , it must be inherited from another class)
-->Abstract class can have a constructor, final methods, private methods , private constructor ...
-->Abstract method:- It can be only used in abstract class and it has no body.
Example:-
---------
abstract class animal{     //abstract class
     public abstract void myanimal();     //abstract method
     public void sample(){
          System.out.println("hello Animal");  //regular method
     }
}
class forest extends animal{
     public void myanimal(){
          //The body of the abstract method is used here or provided here
        System.out.println("Hello Tiger");
     }
}
class Main{
 public static void main(String args[]){
     forest f=new forest();
     f.myanimal();
     f.sample();
   }
}
===============================================================================================================
POLYMORPHISM:-
==================================
-->polymorphism means "many forms" and it occurs when  we have many classes that are related to each other by inheritance.
-->we can re-use attributes and methods of already existing class when a new class is created.
-->There are two of polymorphism they are run time and compile time polymorphisms.
-->public class Animal{
      public void Myanimal(){
         System.out.println("I am a Animal");
       }
   }
   class pig extends Animal{
        public void Myanimal(){
          System.out.println("The pig sounds as: pee pee ");
        }
   }
   class Main{
        public static void main(String args[]){
            Animal myobj = new Animal();
            myobj.Myanimal();
            Animal myobj1 = new pig();
            myobj1.Myanimal();
        }
   }
============================================================================================================
DIFFERENCE BETWEEN COMPILE TIME AND RUN TIME POLYMORPHISMS:-
=================================================================
-->compile-time polymorphism:-
==============================
-->Whenever an object is bound with it's functionality at compile time that is known as compile time polymorphism.
 -->This can be acheived by method-overloading -->method overloading says that it can have more than one fucntion with same name but different parameters in a class.
Example:-
========
class Main{
    public int add(int x , int y){
         return x+y;
    }
  public double add(double x , double y){
         return x+y;
   }
  public static void main(String args[]){
      Main myobj = new Main();
      myobj.add(3,4);
      myobj.add(5.80,6.89);
   }
}
================================================================================================================================================================
-->Run-Time polymorphism:-
  ===========================
-->Whenever an object bound it's functionality at run-time that is known as run-time polymorphism.
-->This can be acheived by method overriding-->method overiding means when a function or method in parent is declared same as in child class and should have 
   same parameters of same type.
Example:-
===========
class parent{
  public  void myMethod(){
       System.out.println("Method 1");
 }
}
class child extends parent{
     public void myMethod(){
       system.out.pintln("Method 2");
     }
 }
class Main{
   public static void main(String args[]){
          child ch = new child();
          ch.myMethod();
    }
 }
=====================================================
Benefits of polymorphism:-
==========================
-->Increases code reusability.
-->Improves readability and maintainability.
-->Supports dynamic binding.
================================================================================================================================================================
INTERFACE IN JAVA:-
====================================
-->Another way to acheive "Abstraction" in java is with interfaces.
-->An "Interface" is a completely "Abstract Class" that is used to group related methods with no body.
-->Example:-
   interface animal{
        public void animalsound(){}
        public void sleep(){}
   }
  class pig extends animal{
        public void animalsound(){
           System.out.println("pig sound as zeeeg");  //abstract method body
        }
         public void sleep(){
             System.out.println("pig sleep as zooo"); //abstract method body
        }
 }
 class Main{
       public static void main(String args[]){
              pig mypig= new pig();
              mypig.animalsound();
              mypig.sleep();
      }
}
-->Similarly multiple interfaces can be developed.
==================================================================================================================================================================
COLLECTIONS IN JAVA:-
=====================
-->These provides below shown methods.
-->"Collections.sort(arr_name or list_name); " -->It is used to sort the elements of array or list.
-->"Collections.copy(arr1,arr2) ;" -->It is used to copy elements from one array to another array. 
-->"Collections.swap(arr,index1,index2);" --">It is used to swap elements of the array.
-->"Collections.reverse(arr);" -->It is used to reverse  elements of the array.
-->"Collections.frequency(arr,ele);"
-->"Collections.max(arr);" -->It is used to find maximum element of the array.
-->"Collections.min(arr);" -->It is used to find minimum element of the array.
-->"Collections.shuffle(arr);"  -->It will rearrange all the elements of the array.
-->"Collections.replaceAll(arr, old_value, new_value);"
-->"Collections.binarySearch(arr,ele);"
-->"Collections.rotate(arr,how_many_rotations);
so these are some the important methods they can be by using collections. 
=================================================================================================================================================================
COLLECTION FRAME WORK IN JAVA:-
==================================
-->Any Group of individual objects which are represented as a single unit known as collection of objects. In java, a seperate framework named as  "COLLECTION 
   FRAMEWORK" has been defined in java jdk1.2 which holds the collection classes and interfaces.
-->following are some of the collection data structures in java.
-->They are:-
        -->ArrayList
        -->LinkedList
        -->HashSet
        -->LinkedHashSet
        -->TreeSet
        -->HashMap
        -->LinkedHashMap
        -->TreeMap
JAVA ARRAYLIST:-
====================
-->The "ArrayList" class is a  resizable array which can be found in the java.util package.
-->The difference between  "built-in array" and "ArrayList" is that for the built array we cannot add or remove elements to/from the built-in array whereas for 
   ArrayList the elements can be added or removed at any place or position.
-->vector is a thread safe and ArrayList is not a thread safe.
-->mutable collection.
-->SYNTAX:-
      import java.util.ArrayList;
      List<data_type> Arraylist = new ArrayList<>();
                   or
      ArrayList<data_type> ArrayName = new ArrayList<data_type>();
-->SOME OF THE USEFUL METHODS THAT ARRAYLIST CLASS HAS:-
   -->"A.add(ele);"  -->it is used to add elements in to the arraylist.
   -->"A.add(index, ele);" -->it is used to add element at the specific position in the list.
   -->"A.addAll(newList);" --> it is used to addall elements of newList to the already existing ArrayList.
   -->"A.get(i);"  -->it is used to access elements inthe arraylist.
   -->"A.set(index, ele);" -->it is used to replace elements at particular position in the arraylist.
   -->"A.remove(index);" -->it is used to remove element at particular index in the arraylist.
   -->"A.indexOf(ele);" -->it will return index of the specific element.
   -->"A.clear();" -->it will entire arraylist.
   -->"A.size();" -->it will print size of the arraylist.
   -->"A.contains(ele);" -->it will checck for whether the element exits or not.and return true or false.
   -->"A.isEmpty();" -->it will true or false based on whether the ArrayList is empty or not.
   -->"A.endsWith("ch");"
   -->"A.startsWith("ch");"
-->for(String c : cars){
      if(c.endsWith("a")){
          System.out.println(c);
      }
      if(c.startsWith("V")){
         System.out.println(c);
      }
}
-->for(int i=0;i<A.size();i++){
    System.out.println(A.get(i));
 }
-->for(int x:A){
 system.out.println(x);
}
================================================================================================================================================================
JAVA LINKEDLIST:-
====================
-->java  LinkedList Class is same as Java ArrayList Class both are having same methods to perform operations.
-->The difference between ArrayList and LinkedList are insertion and deletion of elements are faster in LinkedList when compared to ArrayList.
-->mutable collection.
SYNTAX:-
========
import java.util.LinkedList;
List<data_type> linkedlist = new LinkeList<>();
          or
LinkedList<data_type> L = new LinkedList<data_type>();
-->Following are some of the useful methods that LinkedList has:-
     -->"L.add(ele);" 
     -->"L.add(index,ele);"
     -->"L.get(i);"  --->it is used to access the items in linked list.
     -->"L.size();"
     -->"L.set(i,ele);"   -->it is used to replace an item at the specific position inthe linkedlist.
     -->"L.remove(i);"    -->it is used to remove specific item in the linkedlist at specific position.
     -->"L.clear();"
     -->"L.contians(ele);"  -->return true or false .whether the element presento or not.
     -->"L.isEmpty();"       -->return true or false. whether it is empty or not.
     -->"L.addFirst(parameter);" -->adds an item to the beginning of the  list.
     -->"L.addLast(parameter);"  -->adds an item to the end of the list.
     -->"L.removeFirst();" -->removes an item from the begging of the list.
     -->"L.removeLast();" -->removes an item from the end of the list.
     -->"L.getFirst();" -->get an item at the beginning of the list.
     -->"L.getLast();" -->get an item at the end of the list.          ---->These two methods should be in print statements.
     -->"L.endsWith("ch");"
     -->"L.startsWith("ch");"
-->for(String c : cars){
      if(c.endsWith("a")){
          System.out.println(c);
      }
      if(c.startsWith("V")){
         System.out.println(c);
      }
}
================================================================================================================================================================
 JAVA HASHSET:-
==================
-->It is used to store collection of items where every item is unique and it can found in java.util package.
-->immutable collection.
-->It does not cares about sorted order and  insertion order.
SYNTAX:-
=======
import java.util.HashSet;
 Set<data_type> Hashset = new HashSet<>();
            or
 HashSet<data_type> HashSet_Name = new HashSet<data_type>();

-->Following are some of the useful methods that HashSet has:-
     -->"HashSet_Name.add(ele);" --> it is used to add elements in to the Hashset without caring about insertion and sorted order.
     -->"HashSet_Name.addAll(newSet);"
     -->"HashSet_Name.Contains(ele);" -->it will check whether the element present in the set or not.
     -->"HashSet_Name.size();" -->it will return size of the set.
     -->"HashSet_Name.clear();" -->it will delete entire set at a time.
     -->"HashSet_Name.remove(ele);" -->it will remove specific element in the HashSet.
     -->"HashSet_Name.isEmpty();" -->return true or false  based on whether the HashSet is empty or not.
-->for(int i : HashSet_Name) {
         System.out.println(i);
    }
=================================================================================================================================================================
JAVA TREESET:-
====================
-->TreeSet cares about sorted Order but not about insertion order.
-->HashSet does not cares about both sorted and insertion order.
-->LinkedHashSet cares about insertion order but not about sorted order.
SYNTAX:-
========
Set<data_type> numbers = new TreeSet<>();
      or
TreeSet<data_type> treeset = new TreeSet<data_type>();
-->"numbers.add(ele);" -->it will add  items into the set in sorted order without caring about insertion order.
-->"numbers.floor(ele);" -->it will return the element that is less than or equal to the given parameter.
-->"numbers.lower(ele);" -->it will return the element that is less than the given parameter.
-->"numbers.ceil(ele);" -->it will the return the element that is greater than or equal to the given parameter.
-->"numbers.higher(ele);" -->it will the return the element that is greater than the given parameter.
-->"numbers.subSet(ele1, ele2);" -->ex: [10,12,14,15,17, 18,20,24,26] -->numbers.subSet(15,20); -->[17,18]
-->"numbers.headSet(ele);" -->it will return the elements that are before to the given parameter.
-->"numbers.tailSet(ele);" -->it will return the elements that are after to the given parameter.
=================================================================================================================================================================
PRIORITY QUEUE:-
=================
SYNTAX:-
==========
Queue<Data_type> q = new priorityQueue<data_type>();
-->"q.addAll(newList);" -->it is used to add list of items in to the list.
-->"q.offer(ele);" --->it is used to add element/item in to the queue.
-->"q.poll();"     --->it is used to bring out elements from the queue.
-->"q.remove();"
-->"q.peek();"
===============================================================================================================================================================
JAVA MAP:-
=================
-->MAP stores items or elements as key value pairs.
-->it does not allows duplicates.
-->"HashMap" -->it is unsorted and unordered.
-->"LinkedHashMap" -->it maintains or cares about insertion order.
-->"TreeMap" -->it maintains or cares about sorted order.
SYNTAXES:-
================
-->Map<key,value> map= Map.of("A" , 1 , "B" , 2, "c" , 3);
-->"HashMap<key, value > map = new HashMap<>();"
-->"LinkedHashMap<key,value> map1 = new LinkedHashMap<>();"
-->"TreeMap<key,value> map2 = new TreeMap<>();"
Following are some of the useful methods that MAP has:-
-->"map.put(key,value);" -->it is used to insert key and values into the map.
-->"map.get(key);" -->it is used to access value by using key.
-->"map.size();" -->it will return size of map.
-->"map.clear(); " -->it will delete entire map.
-->"map.isEmpty();" -->it will return true or false based on whether map is empty or not.
-->"map.containsKey(key);" -->it will return true or false.
-->"map.containsValue(value); " -->it will return true or false.
-->"map.remove(key);" -->it is used to remove specific value in the map.
-->"map2.higherkey(key);" --> it will print the key that is greater than the given key.
-->"map2.ceilingKey(key);" --> it will print the key that is grater than or equal to the given key.
-->"map2.lowerKey(key);"  -->it will print the key that is less than the given key.
-->"map2.floorKey(key);"  -->it will print the key that is less than or equal to the given key.
-->"map2.firstEntry();"   -->it will print the first key in the map.
-->"map2.lastEntry();"    -->it will print the last key or entry in the map.
-->"map2.subMap("key1-range" , "key2-range");" -->it will print the subMap of the gievn range.
-->for(data_type c : map.keySet()){
     System.out.println(c); -->it will print all the keys of a map.
  }
-->for(data_type c : map.values()){
        System.out.println( c); -->it will print all the values in a map.
   }
-->To access elements of array into map use the following process:
      for(int i=0;i<A.size();i++){
             m.put(key, m.getOrDefault(key,0)+1);
      }
-->To print Keys ina map by using the map values use the foolowing logic:
 for (Map.Entry<Integer, Integer> entry : m.entrySet()) {
            if (entry.getValue().equals(cnt)) {
                a.add(entry.getKey());
            }
        }
================================================================================================================================================================
JAVA ITERATOR:-
===================
-->java "Iterator" is an object that can be used to loop through collections like "ArrayList" and "HashSet". It is called an iterator because iterating is the technical term for looping.
-->Syntax for creating iterator:-
 ====================================
import java.util.Iterator;
Iterator<data_type> it = Collection_name.iterator();
Example:-
========
import java.util.ArrayList;
import java.util.Iterator;
public class Iterating{
    public static void main(String args[]){
          ArrayList<Integer> A = new ArrayList<>();
          A.add(1); 
          A.add(10);
          A.add(14);
          A.add(16);
          A.add(18);
         //get the iterator
         Iterator<Integer> it = A.iterator();
         //prints the first term
         System.out.println("it.next()");
        //looping through iterator.
        while("it.hasNext()"){
             System.out.println(it.next());
        }
        while(it.hasNext()){
            Integer i = it.next();
            if(i< 10){
               "it.remove();"  //remove items from arraylist or collection by using iterator
            }
       }
      System.out.println(A);
}
}
================================================================================================================================================================
INTRODUCTION TO THREADS AND CONCURRECNY IN JAVA:-
===================================================
-->Thread: Single Sequential flow of control within the Program.
-->Threads allows a programs to operate more efficiently by doing multiple things at the same time.
-->Threads can be used to perform complicated tasks in the background but without interrupting the main program.
-->creating threads :-
     -->Threads can be created in two ways -->by extending the class called thread or by implementing the interface called Runnable.
     -->Inorder to run the single Thread we use the thread by extending Thread Class.
     -->Inorder to run the multiple threads we need to use interface called Runnable.
-->Synatx to create Threads:-
 ===============================
     -->class Task1 extends Thread{
           public void run(){
                 //code
           }
        }
   -->class Task2 implements Runnable{
           public void run(){
              //code
           }
      }
-->How to Run the Threads:-
==================================
  public class Main{
    public static void main(String args[]){
          Task1 task1 = new Task1();
          task1.start();
          Task2 task2 = new Task2();
          Thread thread = new Thread(task2);
          thread.start();
     }
   }
-->"threadname.setPriority(ele);" -->it is used to change the priority of the thread to execute.
-->"threadname.join();" -->it is used for the communication between the threads nothing but one thread has to wait until the another thread completes it's execution .
-->"Thread.sleep(ele);" -->thread utility method
-->"Thread.yeild();"    -->the yield method is used to stop one thread and give time to another thread to execute.
=========================================================================================================================================================
-->EXAMPLE PROGRAM FOR THREADS:-
=================================
package com.sample;
class Task1 extends Thread{
	public void run() {
		System.out.println("\nTask1 Started");
		for(int i=101;i<=199;i++)
		 {
			 System.out.println(i+" ");
		 }
                 try {
			Thread.sleep(10000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		 System.out.println("\nTask1 Done");
	}
}
class Task2 implements Runnable{
	public void run()
	{
		System.out.println("\nTask2 Started");
		for(int i=201;i<=299;i++)
		 {
			 System.out.println(i+" ");
		 }
                 Thread.yeild(); //it is a thread utility method.
		 System.out.println("\nTask2 Done");
	}
}
public class ThreadTasks {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
         //Task1
		System.out.println("\nTask1 Kickedoff");
		Task1 task1 = new Task1();
                task1.setPriority(5);       //it will changes the prority of threads to execute.
		task1.start();
		 //Task2 
		System.out.println("\nTask2 Kickeoff");
		 Task2 task2= new Task2();
		 Thread thread = new Thread(task2);
                 thread.setPriority(1);
		 thread.start();
                 //wait for task1 and task2 to complete their execution
                  task1.join();
                  task2.join();
                //task3 
		 System.out.println("\nTask3 Kickedofff");
		 for(int k=301;k<=399;k++)
		 {
			 System.out.println(k+" ");
		 }
		 System.out.println("\nTask3 Done");
	}
}
-->Physical States of Thread:-
  ===========================
  -->"NEW"
  -->"RUNNABLE"
  -->"RUNNING"
  -->"BLOCKED/WAITING"
  -->"TERMINATED/DEAD"
===============================================================================================================================================================
MULTI THREADING IN JAVA:-
============================
-->THREAD:- single sequential flow of control within the program.
-->Single threaded process can only handle one task at any time.
-->multi-tasking allows single process to run several concurrent threads.
Advantages:-
===========
-->reactive systems
-->parallel processing
-->server can handle mutliple clients simultaneoulsy.
-->Different processes do not share memory spaces.
================================================================================================================================================================
JAVA EXCEPTIONS:-
===================
-->When Executing java Code, different errors can occur:  coding errors made by the programmer , errors due to wrong input ...
-->when an error occurs java will stop normally and shows an error message . The Technical term for this is java will throw an exception.
-->There are two types of exceptions they are :
      -->checked Exceptions -- Exceptions Which are checked during for during compile time are called as checked Exceptions.
      -->Unchecked Exceptions --Exceptions which are not checked for  during compile time  or Exceptions which are checked for during run time are called as 
       unchecked Exceptions.eg: Arithmetic Exception, NullPointer Exception, etc..
-->Try-Catch block handles both checked and unchecked Exceptions.
-->Throws keyword handles only checked Exception.
JAVA TRY AND CATCH:-
====================
-->The "try" Statement allows you to define a block of code to be tested for errors while it is being executed.
-->The "catch" Statement allows you to define a block of code to be executed , if an error occurs in the try block.
SYNTAX:
=======
try{
   //Block of code to try.
}
catch(Exception e){
      //Block of code to handle errors.
}

Example program:
===============
import java.util.*;
public class Main{
  public static void main(Stirng args[]){
      try{
          int[] myNumber= {1,2,3,4};
          System.out.println(myNumbers[10]);
      }
      catch(Exception e){
           System.out.println("Something went wrong");
     }
  } 
}

Throw:-
=======
-->The "throw" statement allows  you to create a custom error.
-->The "throw" statement is used together with an exception type. There are many Exception types in java they are
  "ArithmeticException" ,"FileNotFoundException", "ArrayIndexOutOfBoundsException", "SecurityException" , etc..
-->Example:-
=============
public class Main {
  static void checkAge(int age) {
    if (age < 18) {
      throw new ArithmeticException("Access denied - You must be at least 18 years old.");
    }
    else {
      System.out.println("Access granted - You are old enough!");
    }
  }

  public static void main(String[] args) {
    checkAge(15); // Set age to 15 (which is below 18...)
  }
}
=================================================================================================================================================================
JAVA ENUMS:-
==============
-->An "enum" is a special class that represents a group of "Constants".
-->To create an "enum" , use the enum KeyWord and sperate the constants with comma.
Synatx:-
  enum level{
     low,
     Middle,
     High
 }
-->We can access the enum constants with dot syntax operator.
     level myVar = level.Middle;
-->we can use "enum"  often inside a class.
   public class Main{
      enum level{
          low,
          middle,
          high
      }
       public static void main(String args[]){
          level myVar = level.middle;
          System.out.println(myVar);
       }
 }
-->We can use "enum" often inside the  switch case also..
   enum Level {
  LOW,
  MEDIUM,
  HIGH
}
public class Main {
  public static void main(String[] args) {
    Level myVar = Level.MEDIUM;

    switch(myVar) {
      case LOW:
        System.out.println("Low level");
        break;
      case MEDIUM:
         System.out.println("Medium level");
        break;
      case HIGH:
        System.out.println("High level");
        break;
    }
  }
}
-->Loop through Enum:
    for (Level myVar : Level.values()) {
             System.out.println(myVar);
     }
=================================================================================================================================================================
JAVA 8 Features:-
==========================
  -->Lambda Expressions
  -->Functional Interfaces
  -->Stream API
================================================================================================================================================================
JAVA CHAPTER 1 INTERVIEW QUESTIONS:-
=====================================
-->Why u choosed java and what are the features of java?
-->what is the difference c/c++ and java?
-->what is the difference b/w static and dynamic memory allocation?
-->differecne b/w class and object?
-->what is the difference b/w source code, byte code , binary code or machine level code?
-->what is the difference static v/s Instance data members?
-->what are the different types of Class loaders?
-->what are the different memory managaments in jvm?
-->what is the difference b/w interpreter and JIT?
-->Expalin About Garbage Collection how can we achieve this?
-->Explain about main method why need to have in java?
-->Difference between Static Blocks and instance Blocks.
